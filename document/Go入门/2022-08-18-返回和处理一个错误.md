# 返回和处理一个错误

[toc]

## 一、说明

处理错误是可靠代码极其重要的特性。在这一部分，你将从问候模块添加一点代码去返回一个错误，然后在调用端处理它。

## 二、操作

1. 在`greetings/greetings.go`文件中，添加下面高亮的代码。

   如果不知道问候谁，那么发送问候是没有意义的。如果`name`是空的，返回一个错误给调用者。复制下面的代码到`greetings.go` 文件中，并且保存文件。

   ```go
   package greetings
   
   import (
   	"errors"
   	"fmt"
   )
   
   // Hello 为一个命名的人返回一个问候
   func Hello(name string) (string, error) {
   	// 如果没有给出name，返回一个带有消息的错误
   	if name == "" {
   		return "", errors.New("empty name")
   	}
   	// 如果接受到一个名字，返回一个问候，嵌套名字在消息中
   	message := fmt.Sprintf("Hi, %v. Welcome!", name)
   	return message, nil
   }
   ```

   在这个代码中：

   - 改变了那个函数，以便于它返回两个值：一个字符串和一个error。你的调用者将检查第二个值，去看是否有一个错误发生。（任何Go函数能返回多个值。）
   - 导入Go标准库的`errors`包，以便于你能使用`errors.New`函数。
   - 添加一个`if`语句为了一个检查无效的请求（一个空的name字符串），如果请求是无效的，返回一个错误。`errors.New`函数返回一个带有你的消息在里面的error。
   - 在成功的返回里添加`nil`（意味着没有错误）作为第二个值。这样调用者就可以看到函数成功了。

2. 在你的`hello2/hello2.go`文件中，通过`Hello`函数处理新返回的错误。连同非错误的值。

   复制下面的代码到`hello2.go`文件中：

   ```go
   package main
   
   import (
     "fmt"
     "log"
     
     "example.com/greetings"
   )
   
   func main() {
     // 设置Logger预定义的属性，包含了log项的前缀，和一个禁用打印时间，源文件，行号的标识。
     log.SetPrefix("greetings: ")
     log.SetFlags(0)
     
       // 获取一个问候消息，并打印它
     // message := greetings.Hello("hef")
     // 请求一个问候消息
     message, err := greetings.Hello("")
     // 如果一个错误返回，将它打印到控制台，并退出程序
     if err != nil {
       log.Fatal(err)
     }
     
     // 如果没有错误返回，打印返回到消息到控制台
     fmt.Println(message)
   }
   ```

   在这个代码中：

   - 配置`log`包，为了打印命令名称（“greetings：”）到日志消息到开始，不带时间戳，或源文件信息；
   - 分配Hello到两个返回值，包含`error`指向变量；
   - 将`Hello`的参数从`hef`改为空，以便于你能尝试错误处理的代码；
   - 查看一个非nil的值，在这种情况下继续下面是没有意义的；
   - 使用在`log` 标准库的函数，输出错误消息。如果得到一个错误，使用`log`包的`Fatal`函数将打印错误并停止程序。

3. 在`Hello2`目录的命令行下，运行`hello2.go`文件，验证代码的工作。

   现在你传递一个空的名字，你将得到一个错误。

   ```shell
   $ go run .
   greetings: empty name
   exit status 1
   $
   ```

   这是 Go 中常见的错误处理：将错误作为值返回，以便调用者可以检查它。

