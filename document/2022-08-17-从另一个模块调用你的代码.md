# 从另一个模块调用你的代码

[toc]



## 一、说明

在[上一个部分](https://blog.csdn.net/hefrankeleyn/article/details/126377066)，你创建了一个`greetings`模块。在这一部分，你将写代码调用你刚刚在模块中写的`Hello`函数。你将写代码，可以作为应用执行，并且这段代码调用`greetings`模块。

## 二、步骤

1. 为你的Go模块源代码创建一个`hello2`目录，在这儿你讲写调用者代码。

   在你创建这个目录之后，你应该有一个`hello2`和`greetings`目录，在同一个层级：

   ```shell
   .
   ├── greetings
   └── hello2
   ```

2. 让你写的代码能够依赖跟踪

   为了让你的代码能依赖跟踪，运行`run mod init`命令，给它一个你的代码将要在的模块名字。

   为了本教程的目的，使用`example.com/hello2`作为模块路径。

   ```shell
   $ mkdir hello2
   $ cd hello2/
   $ go mod init example.com/hello2
   go: creating new go.mod: module example.com/hello2
   $ ll
   total 8
   drwxr-xr-x  3 lifei  staff   96  8 17 23:15 ./
   drwxr-xr-x  5 lifei  staff  160  8 17 23:14 ../
   -rw-r--r--  1 lifei  staff   35  8 17 23:15 go.mod
   ```

3. 在你的编译器中，打开`hello2`目录，并创建一个`hello2.go` 文件，将在里面写代码。

4. 写代码调用`Hello`函数，然后打印函数的返回值。

   为了达到这个目的，复制下面的代码到`hello2.go` 文件中：

   ```go
   package main
   
   import (
     "fmt"
     
     "example.com/greetings"
   )
   
   func main() {
     // 获取一个问候消息，并打印它
     message := greetings.Hello("hef")
     fmt.Println(message)
   }
   ```

   在这段代码中：

   - 声明一个main包。在Go中，作为一个应用到可执行代码必须放到`main`包中；

   - 导入两个包：`example.com/greetings`和`fmt`包。这让你的代码使用其它包中的函数。导入`example.com/greetings`（这个包包含在你早期创建的模块中）给你使用`Hello`函数。你也导入`fmt`包，带有处理输入和输出文本的函数（例如，打印文本到控制台）。

   - 获取一句问候，通过调用`greetings`包的`Hello`函数。

     5. 编辑`example.com/hello`模块，去使用你本地的`example.com/greetings`模块。

        为了生产使用，你将从仓库中发布`example.com/greetings`模块（模块路径对应者发布地址），在那儿Go工具能发现并下载它。对于现在，因为你还没有发布这个模块，你需要适配`example.com/greetings`模块，以便于它能在你本地的文件系统中找到`example.com/greetings`的代码。

        为了做到这个，使用`go mod edit`命令去编辑`example.com/hello`模块，去重定向Go工具从它的模块路径（模块是不在的地方）到本地模块（模块在的地方）。

        （1）在`hello2`文件夹下，打开命令行，运行下面的命令：

        ```shell
        $ go mod edit -replace example.com/greetings=../greetings
        $
        ```

        这个命令阐明了`example.com/greetings`应该被`../greetings`代替，为了定位到本地依赖的目的。运行命令之后，在`hello2`文件夹下的`go.mod`文件中包含了替换指示：

        ```shell
        $ cat go.mod
        module example.com/hello2
        
        go 1.18
        
        replace example.com/greetings => ../greetings
        $
        ```

        （2）在`hello2`文件夹下的命令提示符中，运行`go mod tidy`命令去同步`example.com/hello`模块的依赖，添加代码需要但是还没有被跟踪到模块中的东西。

        ```shell
        $ go mod tidy
        go: found example.com/greetings in example.com/greetings v0.0.0-00010101000000-000000000000
        $
        ```

        运行这个命令之后，在`example.com/hello`模块的`go.mod`文件中，将看到下面的内容：

        ```shell
        $ cat go.mod
        module example.com/hello2
        
        go 1.18
        
        replace example.com/greetings => ../greetings
        
        require example.com/greetings v0.0.0-00010101000000-000000000000
        $
        ```

        这个命令在`greetings` 目录中发现本地代码，然后添加一个`require`指向，表明`example.com/hello`需要`example.com/greetings`。当你导入`greetings` 包的时候，你已经创建了这个依赖。

        跟在模块路径后面的数字是一个伪版本号，用于代替语义版本号的生成数字（这个模块还不存在）。

        为了引用已经发布的模块，一个`go.mod`文件通过会忽略`replace`指示，并且使用一个`require`指令带有一个标签版本的数字在结尾。

        ```shell
        require example.com/greetings v1.1.0
        ```

     6. 在`hello2`目录下的命令提示符下，运行代码，验证它是否能工作。

        ```shell
        $ go run .
        Hi, hef. Welcome!
        ```

   