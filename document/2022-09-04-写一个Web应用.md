# 写一个Web应用

[toc]

## 一、介绍

这个教程覆盖的内容：

- 创建一个数据结构，带有load和save方法；
- 使用`net/http`包构建web应用；
- 使用`html/template`包去处理HTML模版；
- 使用`regexp`包去验证用户的输入；
- 使用关闭；

假定知识：

- 编程经验；
- 理解基础的Web技术（HTTP、HTMLL）
- 一些UNIX/DOS命令行知识；

## 二、开始

当下，你需要有一个`FreeBSD`，Linux，macOS，或Windows机器去运行Go。我们将使用`$`代表命令提示符。

安装Go。

在你的`GOPATH`下为你的教程创建一个新的目录，并`cd` 进入它。

```shell
$ mkdir gowiki
$ cd gowiki/
$
```

创建一个名称为`wiki.go` 的文件，在你喜爱的编辑器中打开它，并添加下面的行：

```go
package main

import (
  "fmt"
  "os"
)
```

我们导入来自Go标准库的`fmt`和`os`包。随后，当我们导入额外的功能，我们将添加更多的包到`import` 声明中。

## 三、数据结构

让我们从定义数据结构开始。一个wiki中包含一系列互联的页面组成，每一个都有一个标题和一个内容体（页面的内容）。这儿，我们定义`Page`作为一个数据结构，带有两个字段分别表示标题和内容。

```go
type Page struct {
  Title string
  Body []byte
}
```

类型`[]type`意味着一个byte类型切片。内容的元素是一个`[]byte`而不是一个`string`，因为我们将使用的 io 库所期望的类型，正如我们将在下面看到。

`Page` 结构描述了一个page数据将被如何存储到内存中。但是如何进行持久化存储呢？我们能处理通过创建一个`save`方法在基于`Page`：

```go
func (p *Page) save() error {
  filename := p.Title + "*.txt"
  return os.WriteFile(filename, p.Body, 0600)
}
```

这个方法的签名读作：这儿有一个叫"save"的方法，它的接受者p是一个指向Page的指针。它没有参数，并且返回一个错误类型的值。

这个方法将保存Page的内容到一个文本文件中。为了简单，我们使用`Title`作为文件名。

这个方法返回一个`error`值，因为这是`WriteFile`（一个标准的函数库，用于写一个type切片到文件中）的返回类型。save方法返回一个error值，为了让应用处理在写文件中发生的任何错误。没有如果发生错误，`Page.save`方法将返回`nil`（一个为指针、接口和其它类型的零值）。

八进制的文本`0600`作为第三个参数传递到`WriteFile`中，表示被创建到文件，应该只对当前的用户，具有读写权限。

除了保存文件，我们也将加载页面：

```go
func loadPage(title string) *Page {
  filename := title + ".txt"
  body,_ := os.ReadFile(filename)
  return &Page{Title: title, Body: body}
}
```

`loadPage`函数从标题参数构造文件名，读取文件的内容一个新的变量`body`中，并返回一个指向`Page`文字，由合适的标题和正文值构成。

函数能够返回多个值，标准的库函数`os.ReadFile`返回`[]byte` 和`error`。在`loadPage`中，错误尚未被处理，下划线 (_) 符号表示的“空白标识符”用于丢弃错误返回值（本质上是将值赋值为空）。

但是如果`ReadFile`发生一个错误会发生什么？例如，文件可能不存在。我们不应该忽略这样的错误，让我们修改函数，去返回一个`*Page`和`error`。

```go
func loadPage(title string) (*Page, error) {
  filename := title + ".txt"
  body, err := os.ReadFile(filename)
  if err != nil {
    return nil, err
  }
  return &Page{Title: title, Body: body}, nil
}
```

函数的调用者，现在检查了第一个参数。如果nil，那么加载一个页面是成功的。如果没有，它将返回一个错误，能够被调用者处理。

到现在，我们拥有了一个数据结构，并能够保存和加载文件。让我们写一个`main`函数去测试我们已经写到。

```go
func main() {
  p1 := &Page{Title: "TestPage", Body: []byte("This is a sample Page.")}
  p1.save();
  p2,_ := loadPage("TestPage")
  fmt.Println(string(p2.Body))
}
```

之后，编译并执行这段代码，一个叫`TestPage.txt`到文件将被创建，包含了p1中的内容。文件将被读到p2的结构中，并且它的`Body`元素将打印到屏幕中。

你能编译并运行程序，像这样：

```shell
$ ll
total 8
drwxr-xr-x   3 lifei  staff   96  9  4 18:15 ./
drwxr-xr-x  10 lifei  staff  320  9  4 18:12 ../
-rw-r--r--   1 lifei  staff  553  9 12 10:39 wiki.go
$ go build wiki.go
$ ll
total 3672
drwxr-xr-x   4 lifei  staff      128  9 12 10:44 ./
drwxr-xr-x  10 lifei  staff      320  9  4 18:12 ../
-rwxr-xr-x   1 lifei  staff  1871952  9 12 10:44 wiki*
-rw-r--r--   1 lifei  staff      552  9 12 10:44 wiki.go
$ ./wiki
This is a sample Page.
$
```

## 四、介绍`net/http`包（一个插曲）

这儿有一个完整简单的web 服务工作的例子：

```go
// 忽略了 go build
package main

import (
	"fmt"
	"log"
	"net/http"
)

func handler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "Hi, here, I love %v!", r.URL.Path[1:])
}

func main() {
	http.HandleFunc("/", handler)
	log.Fatal(http.ListenAndServe(":8080", nil))
}
```

main函数从调用`http.HandleFunc`开始，它告诉`http`包处理所有请求到web根"/"，带有handler。

它然后调用`http.ListenAndSave`，指定它应该在任何接口 (":8080") 上侦听端口 8080（现在不用考虑第二个参数，它现在是nil）。这个函数将阻塞，直到程序终止。

`ListenAndSave`总是返回一个错误，因为它仅仅当一个未检测到错误出现才返回。为了打印log，我们包装那个函数，使用`log.Fatal`。

`handler`函数是`http.HandlerFunc`类型。它获取`http.ResponseWriter`和`http.Request`作为参数。

一个`http.ResponseWriter`值，组装了Http 服务的响应。通过写到它里面，我们发送消息到客户端。

一个`http.Request`是一个数据结构，代表客户端到请求。`r.URL.Path` 是请求URL的组合。尾随的`[1:]`意味着，“创建从第一个字符到结尾的路径子片”。这会从路径名中删除前导“/”。

如果你运行程序，并使用下面的URL：

> http://localhost:8080/monkeys

这个程序将返回一个页面，包含：

> Hi, here, I love monkeys!

## 五、使用`net/http`去服务wiki页面

为了使用`net/http`页面，必须导入：

```go
import (
  "fmt"
  "log"
  "os"
  "net/http"
)
```

让我们创建一个handler，`viewHandler`将允许用户去展示wiki页面。它将处理带有“/view/”前缀的URL。

```go
func viewHandler(w http.ResponseWriter, r *http.Request) {
  title := r.URL.Path[len("/view/"):]
  p,_ := loadPage(title)
  fmt.Fprintf(w, "<h1>%s</h1><div>%s</div>", p.Title, p.Body)
}
```

再次，注意使用“_”来忽略从loadPage返回的错误。这是为了简单起见，通常被认为是不好的做法。我们稍后会处理这个问题。

首先，这个函数提取页面的标题从URL路径，这个路径组成了请求路径URL。使用 [len("/view/"):] 重新切片路径以删除请求路径的前导“/view/”组件。这是因为路径总是以`/view/`开始，它不是页面标题的一部分。

这个函数然后加载页面的内容，使用一个简单的HTML格式化页面，并将它写到w中，`http.ResponseWriter`。

为了使用这个处理器，我们重写我们的main函数，使用`viewHandler`初始化http，并处理任何在`/view/`下的请求。

```go
func main() {
  http.HandleFunc("/view/", viewHandler)
  log.Fatal(http.ListenAndServe(":8080", nil))
}
```

让我们创建一些页面数据（例如：`test.txt`），编译我们的代码，并试着服务我们的wiki页面。

在编译器中打开`test.txt` 文件，保存"Hello world"（不带标点符号）在它里面。

```shell
$ go build wiki.go
$ ./wiki

```

随着这个web服务的运行，参观`http://localhost:8080/view/test`应该展示一个页面，标题为"test"，包含的内容为“Hello world”。

## 六、编辑页面

一个wiki不是一个不允许编辑的页面。让我们创造两个新的处理器：一个命名为`editHandler`去展示编辑页面，另一个命令为`saveHandler`，保存通过表单的数据。

首先，我们把他们添加到main函数中：

```go
func main() {
  http.HandleFunc("/view/", viewHandler)
  http.HandleFunc("/edit/", editHandler)
  http.HandleFunc("/save/", saveHandler)
  log.Fatal(http.ListenAndServe(":8080", nil))
}
```

函数`editHandler`页面（如果不存在，创建一个空页面），并且显示HTML表单。

```go
func editHandler(w http.ResponseWriter, r *http.Request) {
  title := r.URL.Path[len("/edit/"):]
  p, err := loadPage(title)
  if err != nil {
    p = &Page{Title: title}
  }
  fmt.Fprintf(w, "<h1>编辑 %s</h1><form action=\"/save/%s\" method=\"POST\"><textarea name=\"body\">%s</textarea><input type=\"submit\" value=\"Save\"></form>", p.Title, p.Title, p.Body)
}
```

这个代码工作良好，但是所有硬编码的HTML是丑陋的。当然，这儿有更好的方案。

## 七、`html/template`包

`html/template` 包是Go标准库的一部分。我们能使用`html/template`将HTML放在独立的文件中，允许我们改变我们编辑页面的布局，不用修改Go代码。

首先，我们必须添加`html/template`到`imports`列表中。我们不再使用`fmt`，因为我们移除它。

```go
import (
  "html/template"
  "os"
  "net/http"
)
```

让我们创建一个模版文件，包含html表单。打开新的文件，命名为`edit.html`，并添加下面的行：

```html
<h1>编辑 {{.Title}}</h1>
<form action="/save/{{.Title}}" method="POST">
  <div>
    <textarea name="body">{{printf "%s" .Body}}</textarea>
  </div>
  <div>
    <input type="submit" value="保存">
  </div>
</form>
```

修改`editHandler`使用模版，替换硬编码的HTML。

```go
func editHandler(w http.ResponseWriter, r *http.Request) {
  title := r.URL.Path[len("/edit/"):]
  p, err := loadPage(title)
  if err != nil {
    p = &Page{Title: title}
  }
  t,_ := template.ParseFiles("edit.html")
  t.Execute(w, p)
}
```

`template.ParseFiles`函数将读取`edit.html`文件内容，并返回一个`*template.Template`。

`t.Execute`方法执行模版，写入生成的HTML到`http.ResponseWriter`中。`.Title`和`.Body`指向`p.Title`和`p.Body`引用。

模板指令用双花括号括起来。`printf "%s" .Body` 指令是一个函数调用，它将 .Body 作为字符串而不是字节流输出，与对 fmt.Printf 的调用相同。`html/template`包有助于确保模板操作仅生成安全且外观正确的 HTML。例如，它会自动转义任何大于号 (>)，将其替换为 &gt;，以确保用户数据不会破坏 HTML 表单。

因为，现在基于模版来工作，因此，让我们创建一个模版为`viewHandler`，叫做`view.html`。

```html
<h1>{{.Title}}</h1>
<p>
  [<a href="/edit/{{.Title}}">edit</a>]
</p>
<div>
  {{printf "%s" .Body}}
</div>
```

修改`viewHandler`：

```go
func viewHandler(w http.ResponseWriter, r *http.Request) {
  title := r.URL.Path[len("/view/"):]
  p,_ := loadPage(title)
  t,_ := template.ParseFiles("view.html")
  t.Execute(w, p)
}
```

注意，我们在两个处理器中使用了非常相似的模版代码。让我们通过将模板代码移动到它自己的函数来删除这个重复：

```go
func renderTemplate(w http.ResponseWriter, tmpl string, p *Page) {
  t,_ := template.ParseFiles("./"+tmpl + ".html")
  t.Execute(w, p)
}
```

修改两个处理器使用这个函数：

```go
func viewHandler(w http.ResponseWriter, r *http.Request) {
	title := r.URL.Path[len("/view/"):]
	p, _ := loadPage(title)
	renderTemplate(w, "view", p)
}

func editHandler(w http.ResponseWriter, r *http.Request) {
	title := r.URL.Path[len("/edit/"):]
	p, err := loadPage(title)
	if err != nil {
		p = &Page{Title: title}
	}
	renderTemplate(w, "edit", p)
}
```

如果我们注释掉我们未实现的保存在main中的注册器，我们能够再次构建并测试我们的程序。

## 八、处理不存在的页面

如果你参观`/view/APageThatDoesntExist`会发生什么？你将看到一个包含HTML的页面。这是因为它忽略了来自`loadPage`返回值的错误，并继续尝试使用空数据填充后模版。相反，如果请求的页面不存在，你应该转发到客户的编辑页面，以便于内容能够创建。

```go
func viewHandler(w http.ResponseWriter, r *http.Request) {
  title := r.URL.Path[len("/view/"):]
  p,err := loadPage(title)
  if 
  t,_ := template.ParseFiles("view.html")
  t.Execute(w, p)
}
```

