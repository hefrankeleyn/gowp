# 写一个Web应用

[toc]

## 一、介绍

这个教程覆盖的内容：

- 创建一个数据结构，带有load和save方法；
- 使用`net/http`包构建web应用；
- 使用`html/template`包去处理HTML模版；
- 使用`regexp`包去验证用户的输入；
- 使用关闭；

假定知识：

- 编程经验；
- 理解基础的Web技术（HTTP、HTMLL）
- 一些UNIX/DOS命令行知识；

## 二、开始

当下，你需要有一个`FreeBSD`，Linux，macOS，或Windows机器去运行Go。我们将使用`$`代表命令提示符。

安装Go。

在你的`GOPATH`下为你的教程创建一个新的目录，并`cd` 进入它。

```shell
$ mkdir gowiki
$ cd gowiki/
$
```

创建一个名称为`wiki.go` 的文件，在你喜爱的编辑器中打开它，并添加下面的行：

```go
package main

import (
  "fmt"
  "os"
)
```

我们导入来自Go标准库的`fmt`和`os`包。随后，当我们导入额外的功能，我们将添加更多的包到`import` 声明中。

## 三、数据结构

让我们从定义数据结构开始。一个wiki中包含一系列互联的页面组成，每一个都有一个标题和一个内容体（页面的内容）。这儿，我们定义`Page`作为一个数据结构，带有两个字段分别表示标题和内容。

```go
type Page struct {
  Title string
  Body []byte
}
```

类型`[]type`意味着一个byte类型切片。内容的元素是一个`[]byte`而不是一个`string`，因为我们将使用的 io 库所期望的类型，正如我们将在下面看到。

`Page` 结构描述了一个page数据将被如何存储到内存中。但是如何进行持久化存储呢？我们能处理通过创建一个`save`方法在基于`Page`：

```go
func (p *Page) save() error {
  filename := p.Title + "*.txt"
  return os.WriteFile(filename, p.Body, 0600)
}
```

这个方法的签名读作：这儿有一个叫"save"的方法，它的接受者p是一个指向Page的指针。它没有参数，并且返回一个错误类型的值。

这个方法将保存Page的内容到一个文本文件中。为了简单，我们使用`Title`作为文件名。

这个方法返回一个`error`值，因为这是`WriteFile`（一个标准的函数库，用于写一个type切片到文件中）的返回类型。save方法返回一个error值，为了让应用处理在写文件中发生的任何错误。没有如果发生错误，`Page.save`方法将返回`nil`（一个为指针、接口和其它类型的零值）。

八进制的文本`0600`作为第三个参数传递到`WriteFile`中，表示被创建到文件，应该只对当前的用户，具有读写权限。

除了保存文件，我们也将加载页面：

```go
func loadPage(title string) *Page {
  filename := title + ".txt"
  body,_ := os.ReadFile(filename)
  return &Page{Title: title, Body: body}
}
```

`loadPage`函数从标题参数构造文件名，读取文件的内容一个新的变量`body`中，并返回一个指向`Page`文字，由合适的标题和正文值构成。

函数能够返回多个值，标准的库函数`os.ReadFile`返回`[]byte` 和`error`。在`loadPage`中，错误尚未被处理，下划线 (_) 符号表示的“空白标识符”用于丢弃错误返回值（本质上是将值赋值为空）。

但是如果`ReadFile`发生一个错误会发生什么？例如，文件可能不存在。我们不应该忽略这样的错误，让我们修改函数，去返回一个`*Page`和`error`。

```go
func loadPage(title string) (*Page, error) {
  filename := title + ".txt"
  body, err := os.ReadFile(filename)
  if err != nil {
    return nil, err
  }
  return &Page{Title: title, Body: body}, nil
}
```

函数的调用者，现在检查了第一个参数。如果nil，那么加载一个页面是成功的。如果没有，它将返回一个错误，能够被调用者处理。

到现在，我们拥有了一个数据结构，并能够保存和加载文件。让我们写一个`main`函数去测试我们已经写到。

```go
func main() {
  p1 := &Page{Title: "TestPage", Body: []byte("This is a sample Page.")}
  p1.save();
  p2,_ := loadPage("TestPage")
  fmt.Println(string(p2.Body))
}
```

之后，编译并执行这段代码，一个叫`TestPage.txt`到文件将被创建，包含了p1中的内容。文件将被读到p2的结构中，并且它的`Body`元素将打印到屏幕中。

你能编译并运行程序，像这样：

```shell
$ ll
total 8
drwxr-xr-x   3 lifei  staff   96  9  4 18:15 ./
drwxr-xr-x  10 lifei  staff  320  9  4 18:12 ../
-rw-r--r--   1 lifei  staff  553  9 12 10:39 wiki.go
$ go build wiki.go
$ ll
total 3672
drwxr-xr-x   4 lifei  staff      128  9 12 10:44 ./
drwxr-xr-x  10 lifei  staff      320  9  4 18:12 ../
-rwxr-xr-x   1 lifei  staff  1871952  9 12 10:44 wiki*
-rw-r--r--   1 lifei  staff      552  9 12 10:44 wiki.go
$ ./wiki
This is a sample Page.
$
```

