# Go的切片

[toc]

## 一、介绍

[Go切片：用法和内部结构](https://go.dev/blog/slices-intro)。

Go的切片类型提供了一个方便和高效的方法作用于序列数据。切片类型类似于其他语言中的数组，但有一些特殊的属性。

## 二、数组

切片类型是建立在Go的数组类型之上的抽象，为了理解切片，我们首先要理解数组。

数组类型定义指定一个长度和元素类型。例如，类型`[4]int` 代表一个拥有四个整数的数组。

一个数组的大小是固定的，它的长度是类型的一部分（`[4]int`和`[5]int`是不同的，不兼容的类型）。

数组能够用通常的方法索引，因此表达式`s[n]`访问从0开始第n个元素。

```go
var a [4]int
a[0] = 1
i := a[0]
// i==1
```

数组不需要被明确的初始化。数组的零值是一个随时可用的数组，数组的元素已经归零。

```go
// a[2] == 0 , int 类型的零值
```

`[4]int`在内部的表示就是四个有序分布的整数值。

Go的数组是值。**一个数组变量表示完整的值；它不是一个指向第一个数组元素的指针**。这意味着当你分配或传递一个数组值你将创建一个它内容的拷贝。（为了避免拷贝，你能传递一个数组的指针，但是之后这是一个指向数组的指针，而不是一个数组。）

一个思考数组的方法是作为一类数据结构，但是拥有索引字段而不是命名字段：一个固定大小的复合值。

一个数组字面上能指定成这样：

```go
b := [2]string{"aa", "bb"}
```

或者，你能让编译器为你计算数组的元素：

```go
b := [...]string{"aa", "bb"}
```

这两种情况，`b`的类型都是`[2]string` 。

## 三、切片

数组拥有它的位置，但是它有点不够灵活，因此你在Go代码中不经常看到它们。然而，切片，无处不在。它们基于数组构建，提供强大的力量和便利。

切片的类型格式是`[]T`，`T`是切片元素的类型。不像数组类型，切片类型不用指定长度。

一个切片的字面上的声明就像一个数组的声明，除了你要忽略数组的数量：

```go
letters := []string{"a", "b", "c", "d", "e"}
```

一个切片能够通过调用内置的`make`函数创建出来，这个内置函数的签名为：

```go
func make([]T, len, cap) []T
```

这里的T代表将要被创建的切片的元素类型。这个`make`函数需要一个类型，一个长度，和一个操作容量。当被调用的时候，make分配一个数组并返回这个数组的切片。

```go
var s []byte
s = make([]byte, 5, 5)
// s == []byte{0, 0, 0, 0, 0}
```

当容量参数被省略的时候，它默认等于指定的长度。这里有一个更简洁版本的代码：

```go
s = make([]byte, 5)
```

切片的长度和容量能够通过内置的`len`和`cap`函数检查：

```go
len(s) == 5
cap(s) == 5
```

接下来两部分将讨论长度和容量的关系。

切片的零值是`nil`。对于一个为`nil`的切片，它的`len`和`cap`函数都将返回0。

一个切片能够通过切片一个存在的切片或数组来形成。切分是通过指定一个半开的范围来完成，这个范围带有两个用冒号分开的索引。例如，表达式`b[1:4]`将创造一个切片包含了b中元素1到3。（结果切片的索引将从0到2）

```go
b := []byte{'g', 'o', 'l', 'a', 'n', 'g'}
// b[1:4] == []byte['o', 'l', 'a'] 和共享相同的存储
```

一个切片表达式的开始和结束索引是可选的，它们分别默认是0和切片的长度。

```go
// b[:2] == []byte['g', 'o']
// b[2:] == []byte['l', 'a', 'n', 'g']
// b[:] == b
```

这也是通过数组来创建切片的语法：

```go
x := [3]string{"aa", "bb", "cc"}
s := x[:] // 一个切片指向x的存储
```

## 四、切片的内部结构

切片是一个数组片段的描述符。它由一个指向数组的指针、片段的长度、它的容量（片段的最大长度）组成。

变量`s`，之前通过`make(byte[], 5)`创建出来，它的结构像这样：

![切片的内部结构](../photos/slice-1.png)

长度是被切片引用的元素的数量。容量是底层数组元素的数量（从切片指针指向的元素开始）。

正如切片`s`，观察切片数据结构的改变和它们和底层数组的联系：

```go
s = s[2:4]
```

![切片的内部结构](../photos/slice-2.png)

切片动作并没有拷贝切片的数据。它创建了一个新的切片值，它的指针指向原始的数组。这种制作切片的操作和操作数组索引一样高效。所以，修改重新切片的元素（不是切片本身）会修改原始切片的元素。

```go
b := []byte{'r', 'o', 'a', 'd'}
e := d[2:]
// e == []byte{'a', d}
e[1] = 'm'
// e == []byte{'a', 'm'}
// b == []byte{'r', 'o', 'a', m}
```

之前我们切分`s`让它的长度小于它的容量。我们能通过再次切分增加它等于它的容量。

```go
s := s[:cap(s)]
```

![切片的内部结构](../photos/slice-3.png)

一个切片不能增长超过它的容量，尝试这样做会引起运行时恐慌，就像索引超过切片或数组的范围。相似的，切片不能被重新切片到零以下去访问数组中更早的元素。

## 五、切片的生长（`copy`和`append`函数）

为了增加切片的容量，必须创建一个新的、更大的切片，并且拷贝原始切片的内容到它里面。这项技术是其它语言的动态数组实现在幕后的工作方式。

下面的例子让`s`的容量翻倍，通过创造一个新的切片`t`，拷贝`s`的内容到`t`中，并分配切片`t`到值给`s`：

```go
t := make([]byte, len(s), (cap(s)+1)*2) // +1 用于cap(s)==0 到情况
for i:= range s {
  t[i] = s[i]
}
s = t
```

这个常见的循环片段操作很容易通过内置的`copy`函数完成。正如名字暗示，`copy`将拷贝数据从原始切片到目标切片，它返回拷贝元素的数量：

```go
func copy(dst, src []T) int
```

这个拷贝函数支持不同切片长度间的拷贝（它只会复制较小数量的元素）。此外，`copy`可以处理共享相同底层数组的源切片和目标切片，从而正确处理重叠切片。

使用`copy`，我们能简化上面的代码片段：

```go
t := make([]byte, len(s), (cap(s)+1)*2)
copy(t, s)
s = t
```

一个常见的操作是添加数据到切片的结尾。这个函数添加byte元素到一个byte类型的切片中，必要的时候增长切片，并返回更新的切片值：

```go
func AppendByte(slice []byte, data ...byte) []byte {
  m := len(slice)
  n := m + len(data)
  if n > cap(slice) { // 如果需要，就重新分配
    // 分配双倍所需，为了将来的增长
    newSlice := make([]byte, (n+1) * 2)
    copy(newSlice, slice)
    slice = newSlice
  }
  slice = slice[0:n]
  copy(slice[m:n], data)
  return slice
}
```

可以像这样使用`AppendByte`：

```go
p := []byte{2, 3, 5}
p = AppendByte(p, 7, 9, 11)
// p == []byte{2, 3, 5, 7, 9, 11}
```

像`AppendByte`函数是有用的，因为它们在切片的生长上提供了完美的控制。依赖于编程语言的特性，它可能需要分配更小或更大的块，或者对重新分配的规模设置上线。

但是更多的程序语言不需要完全的控制，因此Go提供了一个内置的函数，它对绝大多数的目的都是有利的。它的签名如下：

```go
func append(s []T, x ...T) []T
```

这个`append`函数添加`x`元素到切片`s`到结尾，如果更大的容量是需要的话会增长切片。

```go
a := make([]int, 1)
// a == []int{0}
a = append(a, 1, 2, 3)
// a == []int{0, 1, 2, 3}
```

为了把一个切片的内容添加到另一个切片中，使用`...`扩展第二个参数变成列表参数：

```go
a := []string{"aa", "bb", "cc"}
b := []string{"hello", "world", "nihao"}
a = append(a, b...) // 等价于 append(a, b[0], b[1], b[2])
// a == []string{"aa", "bb", "cc", "hello", "world", "nihao"}
```

因为一个零值的切片（`nil`）行为就像零长度的切片。你能声明一个切片变量，并循环向它里面`append`：

```go
// Filter 返回一个新的切片，这个切片近保留满足`fn()`函数的元素
func Filter(s []int, fn func(int) bool) []int {
  var p []int // == nil
  for _, v := range s {
    if fn(v) {
      p = append(p, v)
    }
  }
  return p
}
```

## 六、一个可能的陷阱

就像之前提及的，重新切片没有创建底层数组拷贝。完成的数组将保存在内存中直到不再引用。偶尔这将造成当程序仅仅需要少量片段，而把所有的数据都加载到内存中。

例如，`FindDigits`函数加载文件到内存中，并查询第一组连续的数字，并将它作为一个新的切片返回。

```go
var digitRegexp = regexp.MustComplie("[0-9]+")

func FindDigits(filename string) []byte {
  b, _ := ioutil.ReadFile(filename)
  return digitRegexp.Find(b)
}
```



