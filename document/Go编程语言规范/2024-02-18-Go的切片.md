# Go的切片

[toc]

## 一、介绍

[Go切片：用法和内部结构](https://go.dev/blog/slices-intro)。

Go的切片类型提供了一个方便和高效的方法作用于序列数据。切片类型类似于其他语言中的数组，但有一些特殊的属性。

## 二、数组

切片类型是建立在Go的数组类型之上的抽象，为了理解切片，我们首先要理解数组。

数组类型定义指定一个长度和元素类型。例如，类型`[4]int` 代表一个拥有四个整数的数组。

一个数组的大小是固定的，它的长度是类型的一部分（`[4]int`和`[5]int`是不同的，不兼容的类型）。

数组能够用通常的方法索引，因此表达式`s[n]`访问从0开始第n个元素。

```go
var a [4]int
a[0] = 1
i := a[0]
// i==1
```

数组不需要被明确的初始化。数组的零值是一个随时可用的数组，数组的元素已经归零。

```go
// a[2] == 0 , int 类型的零值
```

`[4]int`在内部的表示就是四个有序分布的整数值。

Go的数组是值。**一个数组变量表示完整的值；它不是一个指向第一个数组元素的指针**。这意味着当你分配或传递一个数组值你将创建一个它内容的拷贝。（为了避免拷贝，你能传递一个数组的指针，但是之后这是一个指向数组的指针，而不是一个数组。）

一个思考数组的方法是作为一类数据结构，但是拥有索引字段而不是命名字段：一个固定大小的复合值。

一个数组字面上能指定成这样：

```go
b := [2]string{"aa", "bb"}
```

或者，你能让编译器为你计算数组的元素：

```go
b := [...]string{"aa", "bb"}
```

这两种情况，`b`的类型都是`[2]string` 。

## 三、切片

数组拥有它的位置，但是它有点不够灵活，因此你在Go代码中不经常看到它们。然而，切片，无处不在。它们基于数组构建，提供强大的力量和便利。

切片的类型格式是`[]T`，`T`是切片元素的类型。不像数组类型，切片类型不用指定长度。

一个切片的字面上的声明就像一个数组的声明，除了你要忽略数组的数量：

```go
letters := []string{"a", "b", "c", "d", "e"}
```

一个切片能够通过调用内置的`make`函数创建出来，这个内置函数的签名为：

```go
func make([]T, len, cap) []T
```

这里的T代表将要被创建的切片的元素类型。这个`make`函数需要一个类型，一个长度，和一个操作容量。当被调用的时候，make分配一个数组并返回这个数组的切片。

```go
var s []byte
s = make([]byte, 5, 5)
// s == []byte{0, 0, 0, 0, 0}
```

当容量参数被省略的时候，它默认等于指定的长度。这里有一个更简洁版本的代码：

```go
s = make([]byte, 5)
```

切片的长度和容量能够通过内置的`len`和`cap`函数检查：

```go
len(s) == 5
cap(s) == 5
```

接下来两部分将讨论长度和容量的关系。

切片的零值是`nil`。对于一个为`nil`的切片，它的`len`和`cap`函数都将返回0。

一个切片能够通过切片一个存在的切片或数组来形成。切分是通过指定一个半开的范围来完成，这个范围带有两个用冒号分开的索引。例如，表达式`b[1:4]`将创造一个切片包含了b中元素1到3。（结果切片的索引将从0到2）

```go
b := []byte{'g', 'o', 'l', 'a', 'n', 'g'}
// b[1:4] == []byte['o', 'l', 'a'] 和共享相同的存储
```

一个切片表达式的开始和结束索引是可选的，它们分别默认是0和切片的长度。

```go
// b[:2] == []byte['g', 'o']
// b[2:] == []byte['l', 'a', 'n', 'g']
// b[:] == b
```

这也是通过数组来创建切片的语法：

```go
x := [3]string{"aa", "bb", "cc"}
s := x[:] // 一个切片指向x的存储
```





