# Go的声明语法

[toc]

## 一、介绍

对于Go的新人，想要知道为什么声明语法是不同于在C家族已建立的传统。在这篇文章中，我们将对比两种方法，并解释为什么Go的声明看起来如此。

## 二、C语法

首先，让我们谈论C的语法。C采用了一种不同寻常并且聪明的方法对于声明语法。与使用特殊语法描述类型相反，而是写了一个包含声明项的表达式，并说明表达式将有什么类型。因此

```c
int x;
```

声明x是int类型：表达式"x"将具有int类型。一般来说，为了弄清楚如何编写新变量的类型，写一个涉及该变量的表达式，该变量的计算结果为基本类型，那么把基本类型放到左边，表达式在右边。

因此，声明：

```c
int *p;
int a[3];
```

声明p是一个指向int的指针，因为`*p`拥有类型int，并且a是一个int 数组，因为`a[3]`（忽略特定的索引值，它是数组的大小）有一个类型int。

什么是函数？起初，C的函数声明把参数类型写到括号外面，像这样：

```c
int main(argc, argv)
  int argc;
  char *argv[];
{/*......*/}
```

又一次，我们说main是一个函数，因为表达式`main(argc, argv)`返回一个int值。在现代的符号中，我们会写：

```c
int main(int argc, char *argv[]) { /*......*/ }
```

但是那个基础的结构是相同的。

这是一个清晰的语法想法，对于简单的类型它工作得很好，但是很快让人困惑。著名的例子是声明一个函数指针。遵守规则，你会得到：

```c
int (*fp)(int a, int b);
```

这里，fp是一个函数指针，因为如果你写那个表达式`(*fp)(a, b)`你将调用函数，并返回int。如果 fp 的一个参数本身就是一个函数怎么办？

```c
int (*fp)(int (*ff)(int x, int y), int b)
```

这阅读开始变得困难。

当然，当我们在声明一个函数的时候，我们能忽略参数的名字。因此，main函数能声明成：

```c
int main(int, char *[])
```

回想一下argv的声明像这样：

```c
int *argv[]
```

因此你删除了声明中间的名字，变成了构造它的类型。但是，通过将名称放在中间来声明 char *[] 类型的东西并不明显。

让我们看看fp的声明发生了什么事儿，如果你不写参数的名字：

```c
int (*fp)(int (*)(int, int), int)
```

将名称放在其中的位置不仅不明显，而且根本不完全清楚它是一个函数指针声明。

```c
int (*)(int, int)
```

如果返回类型也是一个函数指针，将会发生什么？

```c
int (*(*fp)(int (*)(int, int), int))(int, int)
```

它甚至很难看出它是一个fp的声明。

你能构造更精心制作的例子，但这些应该说明 C 的声明语法可能引入的一些困难。

不过，这儿有一点需要说明。因为类型和声明语法是相同的，解析中间有类型的表达式可能很困难。这是为什么，C 强制转换总是给类型加上括号，如：

```c
(int)M_PI
```

## 三、Go的语法

C系列之外的语言通常在声明中使用一个不同的类型语法。虽然它是一个单独点，但名称通常是第一位，通常后面跟着一个冒号。因此我们上面的例子变成了（用一个虚构的但说明性的语言）：

```
x: int
p: pointer to int
a: array[3] of int
```

这些声明是清晰的，如果冗长的话——只需要从左到右读它们。Go从这儿得到提示，但是感兴趣简化它，删除了冒号，并且移除了某些关键词：

```go
x int
p *int
a [3]int
```

`[3]int`的外观和如何使用一个表达式之间没有直接的关系。（在下部分我们将会到指针。）以单独的语法获取清晰度。

现在考虑函数。让我们为main录制声明，正如它在Go中读的，尽管在真正的Go中的main函数中没有参数：

```go
func main(argc int, argv []string) int
```

表面上它和C没有太多的区别，除了从char数组变成字符串，但它从左到右读的非常好。

main函数获取一个int和一个字符串切片，并且返回一个int。

删除参数名称，它同样清晰：他们总是第一个，所以没有混淆。

```go
func main(int, []string) int
```

这样从左到右的一个好处是，类型变得复杂，它工作的依然非常好。这儿是一个函数变量的声明（类似于C中的函数指针）：

```go
f func(func(int, int) int, int) int
```

或者如果f是一个函数

```go
f func(fun(int, int) int, int) func(int, int) int
```

它仍然读的很清楚，从左到右。并且哪个名称被声明总是很明显——名称是第一位的。

类型和表达式语法之间的区别使得在 Go 中编写和调用闭包变得很容易：

```go
sum := func(a, b, int) int { return a+b } (3, 4)
```

## 四、指针

指针是证明规则的例外。请注意在数组和切片中，例如，Go的类型语法，括号放在类型的左边，但是表达式语法放它们在表达式的右边。

```go
var a = []int
x = a[1]
```

为了方便，Go的指针使用来自C的`*` 符号。但是我们不能让自己对指针类型进行类似的反转，因此，指针的工作看起来像这样：

```go
var p *int
x = *p
```

我们不能说：

```go
var p *int
x = p*
```

因为那个后缀 * 会和乘法混为一谈。我们可以使用`^`，例如：

```go
var p ^int
x = p^
```

也许我们应该有（并为 异或 选择另一个运算符），因为前缀的星号在类型和表达式上都以多种方式使事情复杂化。例如，虽然可以写：

```go
[]int("hi")
```

作为一种转换，如果类型以 * 开头，则必须用括号括起来：

```go
(*int)(nil)
```

如果我们愿意放弃 * 作为指针语法，那么这些括号将是不必要的。

所以 Go 的指针语法与熟悉的 C 形式联系在一起，但这些联系意味着我们不能完全摆脱使用括号来消除语法中的类型和表达式的歧义。

不过总的来说，我们相信 Go 的类型语法比 C 的更容易理解，尤其是当事情变得复杂时。





