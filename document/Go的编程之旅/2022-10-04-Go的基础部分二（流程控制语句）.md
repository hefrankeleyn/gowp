# Go的基础部分二（流程控制语句）

[toc]

## 一、For

Go仅有一个循环结构，`for`循环。

基础的`for`循环有三部分用分号分开：

- 初始化语句：在第一次迭代前执行；
- 条件表达式：在每次迭代前进行判断；
- 陈述语句：在每次迭代后执行；

初始化语句通常是一个短变量的声明，并且被声明的变量仅在`for`陈述范围内可见。

循环将停止迭代，一旦布尔条件证明是false。

注意：并不像其他的语言，比如C，Java，或JavaScript，这儿没有一个括号包围着`for`语句的三部分，并且大括号`{}`总是需要的。

```go
package main

import "fmt"

func main() {
	sum := 0
	for i := 0; i < 10; i++ {
		sum += 1
	}
	fmt.Println(sum)
}
```

初始化语句和 陈述语句是可选的。

```go
package main

import "fmt"

func main() {
	sum := 1
	for sum < 100 {
		sum += sum
	}
	fmt.Println(sum)
}
```

## 二、For是Go的“while”

在那个时候（不带初始化语句和陈述语句），就可以删除分号：C中的`while`在Go中用for拼写。

```go
package main

import "fmt"

func main() {
	sum := 1
	for sum < 100 {
		sum += sum
	}
	fmt.Println(sum)
}
```

## 三、无限循环

如果你忽略循环条件，它就是无限循环。因此无限循环是一个紧凑的表达式。

```go
package main

func main() {
	for {

	}
}
```

## 四、IF

Go的`IF`语句像一个`For`循环；这个表达式不需要被`()`括号包围，但是大括号`{}`是必须的。

```go
package main

import (
	"fmt"
	"math"
)

func sqrt(x float64) string {
	if x < 0 {
		return sqrt(-x) + "i"
	}
	return fmt.Sprint(math.Sqrt(x))
}

func main() {
	fmt.Println(sqrt(2), sqrt(-4))
}
```

## 五、IF带有一个短的陈述

像`For`，`if`语句能够以一个短的表达式开始，在条件之前执行。

这个语句中声明的变量，仅在范围内直到if结束能用。

（试着在结束的`return`语句中使用`v`）

```go
package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	}
	// return v
	return lim
}

func main() {
	fmt.Println(
		pow(3, 1, 10),
		pow(3, 3, 20),
	)
}
```

## 六、IF和else

在一个`IF`短语句里面声明的变量也能够在任意的`else`块中使用。

（在 main 中对 fmt.Println 的调用开始之前，对 pow 的两个调用都会返回它们的结果）

```go
package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	} else {
		fmt.Printf("%g >= %g\n", v, lim)
	}
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}
```

## 七、练习：循环和函数

作为使用函数和循环的一种方法，让我们实现一个平方根函数：给定一个数字x，我们想要找到一个数字z，让z^2非常接近x。

电脑通常使用循环来计算x的平方根。使用某一个猜测的z开始，我们能够调整z基于z^2不断接近x，产生一个更好的猜测。

```go
z -= (z*z - x) / (2*z)
```

重复这个调整，让猜测越来越好，直到我们得到一个回答，它是接近实际的平方根的答案。

在提供的`func Sqrt` 中实现。一个对z体面的猜测是从1开始，无论输入是什么。首先，重复这个计算十次，并且沿途打印每次的z。看看您与 x (1, 2, 3, ...) 的各种值的答案有多接近，以及猜测改进的速度有多快。

提示：为了声明和初始化一个浮点值，给它浮点语法，或者使用类型转换：

```go
z := 1.0
z := float64(1)
```

接下来，改变循环条件去停止，一旦值停止改变（或者仅仅改变非常小的数）。看看是多于还是少于 10 次迭代。尝试对于z的另一个初始化猜测，比如x，或x/2。

注意：如果你感兴趣详细的算法，上面的 z² − x 是 z² 与它需要的位置 (x) 的距离，除以 2z 是 z² 的导数，以根据 z² 的变化速度来衡量我们调整 z 的程度。这个方法通常被称为牛顿法。它工作的非常好对于很多函数，尤其是对平方根。

```go
package main

import (
	"fmt"
)

func Sqrt(x float64) float64 {
	z := 1.0
	for i := 1; i <= 10; i++ {
		z -= (z*z - x) / (2*z)
		fmt.Println(z)
	}
	return z
}

func main() {
	fmt.Println(Sqrt(2))
}
```

最终的结果：

```go
package main

import (
	"fmt"
	"math"
)

func Sqrt(x float64) float64 {
	z := 1.0
	var t float64
	for {
		// t = z
		// z -= (z*z - x) / (2 * z)
		z, t = z-(z*z-x)/(2*z), z
		if math.Abs(t-z) < 1e-6 {
			return z
		}
	}
	return z
}

func main() {
	fmt.Println(Sqrt(2))
	fmt.Println(Sqrt(4))
}
```

## 八、Switch

一个`Switch`语句是一个非常短的方法去写一个`if-else`序列。它运行第一个值等于条件表达式的用例。

Go的switch和C、C++、Java、JavaScript、和PHP中的非常像。除了Go仅仅运行选中的用例，下面的所有用例不会运行。实际上，Go中自动提供了在其他语言中需要用的`break`语句。另一个重要的不同是，Go的switch用例不必是常量，所涉及的值不必是整数。

```go
package main

import (
	"fmt"
	"runtime"
)

func main() {
	fmt.Print("go 运行在：")
	switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("OS X.")
	case "linux":
		fmt.Println("Linux.")
	default:
		fmt.Printf("%s.\n", os)
	}
}
```

## 九、Swith的验证顺序

Switch用例的验证是从顶到底进行验证，当一个用例成功的时候停止。

例如：

```go
switch i {
  case 0:
  case f():
}
```

如果 `i==0`就不会调用`f`。

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("When's Saturday?")
	today := time.Now().Weekday()
	switch time.Tuesday {
	case today + 0:
		fmt.Println("Today.")
	case today + 1:
		fmt.Println("Tomorrow.")
	case today + 2:
		fmt.Println("In two days.")
	default:
		fmt.Println("Too far away.")
	}

}
```

## 十、不带条件的switch

不带条件的switch类似于`switch true`。

这个结构能够成为一个干净的方法去写一个长的`if-then-else`链。

```go
package main

import (
	"fmt"
	"time"
)

func main() {
	t := time.Now()
	switch {
	case t.Hour() < 12:
		fmt.Println("Good morning!")
	case t.Hour() < 17:
		fmt.Println("Good afternoon.")
	default:
		fmt.Println("Good evening.")
	}
}
```

## 十一、Defer  延迟

一个Defer语句推迟执行函数，直到周围函数返回。

延迟调用的参数会被立即评估，但是函数的调用是不会执行，直到周围的函数返回。

```go
package main

import "fmt"

func main() {
	defer fmt.Println("world")

	fmt.Println("Hello ")
}
```

## 十二、堆叠延迟

延迟的函数是被推送到栈中。当一个函数返回，它延迟的调用会按照“后进先出”的顺序被执行。

为了学习更多关于延迟语句，阅读[Defer, Panic, and Recover](https://go.dev/blog/defer-panic-and-recover)。

```go

```

