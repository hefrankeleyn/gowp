# 开始使用模糊测试

[toc]

## 一、介绍

这篇指导介绍Go中基础的模糊测试。通过模糊测试，随机数据会针对您的测试运行，以尝试找出漏洞或导致崩溃的输入。例如，通过模糊测试能够发现SQL注入的漏洞，缓冲区溢出，拒绝服务或者跨域攻击。

在这篇指导中，你将为一个简单的函数写一个模糊测试，运行Go命令行，调试并修复代码中的问题。

你将通过下面的部分：

1. 为你的代码创建一个目录；
2. 添加代码用于测试；
3. 添加单元测试；
4. 添加模糊测试；
5. 修复两个bug；
6. 探索更多的资源；

## 二、准备

- 安装Go1.18 或以上版本；
- 一个用于编写代码的工具；
- 命令行工具；
- 一个支持模糊测试的环境。目前仅在 AMD64 和 ARM64 架构上使用覆盖检测进行模糊测试。

## 三、实践

### 3.1 为你的代码创建一个目录

1. 打开命令行，进入到工作目录

   从为你将要写的代码创建目录开始。

   ```shell
   $ cd 
   $
   ```

2. 通过命令行，创建一个名称为`fuzz`的目录

   ```shell
   $ mkdir fuzz
   $ cd fuzz/
   $
   ```

3. 为你的代码创建一个模块

   运行`go mod init`命令，并给它一个新的代码模块路径

   ```shell
   $ go mod init example/fuzz
   go: creating new go.mod: module example/fuzz
   $
   ```

接下来，你将添加一些简单代码去反转字符串，它将用于模糊。

### 3.2 添加代码用于测试

在这一步，将添加函数用于反转字符串。

#### 写代码

1. 使用文本编辑器，在fuzz目录中，创建一个叫`main.go`的文件。

2. 进入`main.go`文件，在文件的顶部，粘贴下面的代码声明。

   ```go
   package main
   ```

   一个独立的程序（和标准库相反），总是在main包中。

3. 在包声明的下面，粘贴下面的函数声明

   ```go
   func Reverse(s string) string {
     b := []byte(s)
     for i,j := 0, len(b)-1; i < len(b)/2; i, j = i+1, j-1{
       b[i], b[j] = b[j], b[i]
     }
     return string(b)
   }
   ```

   函数接受一个字符串，同时循环byte，最后返回反转的字符串。

   注意：这个代码基于`golang.org/x/example`的`stringUtils.Reverse`函数。

4.  在`main.go`文件的顶部，在包声明的下面，粘贴下面的main函数去初始化一个字符串，反转它，打印输出，并重复这样做

   ```go
   func main() {
     input := "The quick brown fox jumped over the lazy dog"
     rev := Reverse(input)
     doubleRev := Reverse(rev)
     fmt.Printf("original: %q\n", input)
     fmt.Printf("reversed: %q\n", rev)
     fmt.Printf("reversed agained: %q\n", doubleRev)
   }
   ```

   这个函数将运行`Reverse` 操作，然后打印命令行的输出。这个是有用的，在实践中查看代码，也是有用的对于发现潜在的debug。

5. `main` 函数使用了`fmt`包，因此，你将需要导入它。

   第一行代码看起来像这样：

   ```go
   package main
   import "fmt"
   ```

#### 运行代码

在包含`main.go`文件目录的命令行下，运行代码：

```shell
$ go run .
original: "The quick brown fox jumped over the lazy dog"
reversed: "god yzal eht revo depmuj xof nworb kciuq ehT"
reversed agained: "The quick brown fox jumped over the lazy dog"
$ 
```

你能看到原始数据，反转的结果数据，然后对结果再次旋转。它和原始数据相等。

现在代码正在运行，是时间去测试它了。

### 3.3 添加单元测试

在这一步，你将为Reverse函数写基础的单元测试。

#### 写代码

1. 使用你的文本编辑器，在fuzz目录中，创建一个文件叫做`reverse_test.go`

2. 粘贴下面的代码到`reverse_test.go`

   ```go
   package main
   
   import (
     "testing"
   )
   
   func TestReverse(t *testing.T) {
     testcases := []struct {
       in, want string
     }{
       {"Hello, world", "dlrow ,olleH"},
       {" ", " "},
       {"!12345", "54321!"},
     }
     for _, tc := range testcases {
       rev := Reverse(tc.in)
       if rev != tc.want {
         t.Errorf("Reverse: %q, want %q", rev, tc.want)
       }
     }
   }
   ```

   这个简单的函数将断言，那一列输入的字符串将被正确的反转。

#### 运行代码

使用`go test` 运行单元测试。

```shell
$ go test
PASS
ok  	example/fuzz	0.325s
$ go test -v
=== RUN   TestReverse
--- PASS: TestReverse (0.00s)
PASS
ok  	example/fuzz	0.253s
$
```

接下来，你将改变单元测试变成模糊测试。

### 3.4 添加模糊测试

单元测试拥有局限性，即每次输入必须被开发者添加到测试。一个模糊测试的好处是它能为你的代码创建输入，并且能确认边缘化的用例，那些你没有想象出来的用例。

在这一部分你将转换单元测试变成模糊测试，以便于你能通过少量的工作产生更多输入。

注意，你将保留单元测试、基准测试和模糊测试在相同的`*_test.go`文件下面。但是对于这个案例，你将转换单元测试成为模糊测试。

#### 写代码

在你的文本编译器中，使用下面的模糊测试替换单元测试。

```go
func FuzzReverse(f *testing.F) {
  testcase := []string{"Hello World", " ", "!12345"}
  for _, tc := range testcase {
    f.Add(tc)
  }
  f.Fuzz(func(t *testing.T, orig string)) {
    rev := Reverse(orig)
    doubleRev := Reverse(rev)
    if orig != doubleRev {
      t.Errorf("Before: %q, after: %q", orig, doubleRev)
    }
    if utf8.ValidString(orig) && !utf8.ValidString(rev) {
      t.Errorf("Reverse produced invalid UTF-8 string %q", rev)
    }
  }
}
```

Fuzzing也有一些局限性。在你的单元测试中，你能预测`Reverse`函数期待的输出，并且验证实际的输出满足预期。

例如，在测试用例`Reverse("Hello, world")`单元测试明确返回`dlrow ,olleH`。

使用模糊查询，你不能预测期待的输出，因为你不能控制输入。

可是，这里有一些`Reverse`函数的属性，你能在fuzz测试中进行验证。其中两个能在模糊测试中验证的是：

1. 反转字符串两次，保留原始值；
2. 反转的字符串将其状态保留在UTF-8；

注意在单元测试和模糊测试中的语法不同。

- 函数以`FuzzXxx`开头代替`TestXxx`，并且获取`*testing.F`代替`*testing.T`；
- 在你期待看到`t.Run`执行的地方，你替换成`f.Fuzz`，在那儿你获取一个模糊测试的函数，它的参数是`*testing.T`和一个用于模糊执行的类型。单元测试的输入使用 f.Add 作为种子语料库输入提供。

确保新的包`unicode/utf8`是被导入。

```go
package main

import (
  "testing",
  "unicode/utf8"
)
```

使用模糊测试覆盖单元测试，同时，再次运行测试。

