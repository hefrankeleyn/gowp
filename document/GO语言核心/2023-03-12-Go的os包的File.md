# Go的OS包

[toc]

## 一、OS包的作用

os包中的API主要可以帮助我们使用操作系统中的文件系统、权限系统、环境变量、系统进程，以及系统信号。

对于类Unix的操作系统，其中的一切都可以被看作文件。因此可以利用`os.File`类型操作的东西很多。

本篇文章把`os.File` 类型应用于常规的文件。

## 二、`os.File` 类型实现了哪些`io`包的接口

`os.File`拥有的都是指针方法，所以除了空接口以外，它本身没有实现任何接口。而它的指针类型则实现了很多io代码包中的接口。

- `*os.File`实现了io包中三个最核心的简单接口：`io.Reader`、`io.Writer`、`io.Closer`；

- `*os.File`还实现了另外三个简单接口：`io.ReaderAt`、`io.Seeker`、`io.WriterAt`；

- 由于`*os.File`实现了上面六个简单接口，所以它顺便实现了io包中9个扩展接口中的7个：`io.ReadWriter`、`io.ReadCloser`、`io.ReadSeeker`、`io.ReadWriteCloser`、`io.ReadWriteSeeker`、`io.WriteCloser`、`io.WriteSeeker`。

  > 由于·`*os.File`没有实现简单接口`io.ByteReader`和`io.RuneReader`，所以它没有实现它没有实现作为它两者的扩展接口：`io.ByteScanner`和`io.RuneScanner`。

所以，`os.File`可以读写文件，并读取和设定下一次读写的起始索引位置。还可以对文件进行关闭。但是，并不能专门地读取文件的下一个字节，或者写一个Unicode字符，也不能进行任何的读回退操作。

## 三、创建`os.File`类型的指针类型

在os包中，有这样几个函数：Create、NewFile、Open和OpenFile。

### 3.1 `os.Create`

`os.Create`函数用于根据指定的路径创建一个新的文件。

使用这个函数创建的文件，对于操作系统中的所有用户来说，都是可以读和写的。

- 如果在我们给予`os.Create`函数的路径之上，已经存在一个文件，那么该函数会清空现有文件中的全部内容，然后再把它作为第一个结果值返回；
- 如果给定的路径的某一级父目录并不存在，该函数就会返回一个`*os.PathError`类型的错误值，以表示“不存在的文件或目录“。

### 3.2 `os.NewFile`

该函数在被调用的时候，需要接受一个代表文件描述符的uintptr类型的值，以及一个用于表示文件名的字符值。

- 如果给定的文件描述符不是有效的，那么函数将返回nil。否则，它将会返回一个代表了相应文件的File值；

这个函数的功能并不是创建一个新的文件，而是依据一个已经存在的文件描述符，来新建一个包装了该文件的File值。

### 3.3 `os.Open`

`os.Open`函数会打开一个文件并返回包装了该文件的File值。然而，该函数只能以只读模式打开文件。

> 换句话说，我们只能从该函数返回的File值中读取内容，而不能向它写入任何内容。

如果调用它的任何一个写入方法，都会得到一个表示“坏的文件描述符”的错误值。

`os.File`类型有一个指针方法Fd，它在被调用之后将会返回一个uintptr 类型的值，这个值就代表了当前的File值所持有的那个文件描述符。

### 3.4 `os.OpenFile`

`os.OpenFile`其实是`os.Open`、`os.Create`函数的底层支持，它最为灵活。

这个函数有3个参数：

- name：文件路径；
- flag：需要施加在文件描述符之上的模式；比如，只读模式（由`os.O_RDONLY`）。操作模式
- perm：代表的也是模式，类型是`os.FileMode`，是一个基于uint32类型的再定义类型。权限模式。

操作模式限定了文件的方式，权限模式控制文件的访问权限。

## 四、`os.File`值的操作模式有哪些

针对File值的操作模式主要有：只读模式、只写模式和读写模式。

- 只读模式：`os.O_RDONLY`
- 只写模式：`os.O_WRONLY`
- 读写模式：`os.O_RDWR`

更多的操作模式：

- `os.O_APPEDN` ：写内容是，追加在现有内容的后面；
- `os.O_CREATE` ：当给定路径上的文件不存在时，创建一个新文件；
- `os.O_EXCL`：需要和`os.O_CREATE`一同使用，表示给定的路径上不能有存在的文件。
- `os.O_SYNC `：在打开文件之上实施同步I/O。它会保证读写的内容总会与硬盘上的数据保持同步。
- `os.O_TRUNC`：如果文件已存在，并且是常规的文件，那么就先清空其中已存在的任何内容。

多个操作模式是通过按位操作符`|`组合起来的。

```go
func Create(name string) (*File, error) {
	return OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)
}
```

```go
func Open(name string) (*File, error) {
	return OpenFile(name, O_RDONLY, 0)
}
```

## 五、`os.OpenFile`的第三个表示模式的参数

`os.OpenFile`函数的第三个参数perm代表的是权限模式，它的类型是`os.FileMode`。实际上，`os.FileMode`能够代表的不仅是权限模式，还可以代表文件模式（也可以称为文件种类）。

`os.FileMode`是基于uint32类型的再定义类型，包含23个比特位，在这23个比特位，每个比特位都有特定的含义。

- 如果在最高比特位的二进制数是1，该文件模式就等同于`os.ModeDir`，也就是说相应的文件是一个目录。
- 如果在第26位比特位的二进制数是1，该文件模式就等同于`os.ModeNamedPipe`，也就是说该文件是一个命名管道。

`os.FileMode`只有最低9个比特位才用于表示文件的权限。

拿`os.FileMode`类型的值与`os.ModePerm`常量（值为0777）做按位与操作，得到的值就表示对应的权限模式。

这9个比特位，3个为一组，共3组。从高到低，分别表示：文件所有者（创建文件的那个用户）、文件所属的用户组、用户对该文件的访问权限。而对于每个组，其中的3个比特位从高到低分别表示：读权限、写权限、执行权限。

> 某个比特位上是1，表示相应的权限开启，否则，就表示相应的权限关闭。

- 八进制整数0777就表示：操作系统中的所有用户都对当前的文件有读、写和执行的权限；
- 而八进制整数0666则表示：所有用户都对当前文件有读和写的权限，但都没有执行的权限。

但要注意，**只有在新建文件的时候，这里的第三个参数值才是有效的**。在其他情况下，即使我们设置了此参数，也不会对目标文件产生任何的影响。

