# Go语言基础

[toc]

## 一、说明

下面是一些参考资料：

- [Go官网](https://golang.google.cn/)

- [Go语言规范文档](https://golang.google.cn/ref/spec)
- [Go官方命令文档页面](https://golang.google.cn/cmd/go/)
- [Go命令命令教程](https://github.com/hyper0x/go_command_tutorial)

```shell
# 在命令行查看go命令的使用
$ go help build
```

- [官网flag命令](https://golang.google.cn/pkg/flag/)

示例代码：

- []()

## 二、工作区和GoPath

Go安装成功后，可以通过`go version`验证是否安装成功：

```shell
$ go version
go version go1.18.3 darwin/amd64
$
```

安装的过程，需要配置三个环境变量：

- `GOROOT`：go语言的安装目录；
- `GOPATH`：若干个工作区目录的路径。是我们自定义的工作空间。
- `GOBIN`：Go语言生成的可执行文件的路径。

源码文件：通常存放在某个工作区的src子目录下；

代码包的导入路径：比如`import "github.com/labstack/echo"`, “github.com/labstack/echo”就是导入路径；

归档文件：

命令：`go build`、`go get`

## 三、源码文件

### 3.1 命令源码文件

#### （1）特点

- 独立程序的入口
- 属于main包，包含无参数无结果的main函数；
- main函数执行结束，意味着当前程序运行的结束；
- 同一个代码包中，不要放多个命令源码文件；
- 命令源码文件和苦源码文件也不要放在同一个代码包；

#### （2）构建

构建后生成可执行文件：

- 在命令行中运行的文件；
- 在Windows中就是扩展名为".exe"的文件；
- 在Linux中一般无扩展名；

生成位置在命令执行目录。

#### （3）安装

安装后，形成可执行文件。

生成的位置在当前工作区的bin子目录或GOBIN包含的目录。

#### （4）深入了解命令源码文件

如果一个源码文件声明属于main包，并且有一个无参数声明且无结果声明的main函数，那么它就是命令源码文件。

**对于一个独立的程序，命令源码文件永远只有一个**。

通过构建或安装命令源码文件，生成的可执行文件可以视作“命令”。

#### （5）命令源码文件接收参数

```java
package main

import (
	"flag" // go 语言标准库中的一个代码包
	"fmt"
)

var name string //

func init() {
	fmt.Println("运行init函数....")
	// flag 接收四个参数
	//     第一个参数： 用于存储该命令参数值的地址；
	//     第二个参数： 用于指定该命令参数的命令；
	//     第三个参数： 指定在未追加该命令参数时的默认值，这里是everyone；
	//     第四个参数： 该命令参数的简要说明
	// flag.String()  会直接返回一个已经分配好的用于存储命令参数值的地址。
	// var name = flag.String("name", "everyone", "The greeting object.")
	flag.StringVar(&name, "name", "everyone", "The greeting object.")

}

func main() {
	fmt.Println("运行main函数.....")
	// 用于真正解析命令参数，并把它们的值赋给相应的变量
	// 该函数的调用必须放在所有命令参数存储载体的声明（这里是对变量name的声明）和设置（这里是falg.StringVar函数的调度）之后，
	// 并且在读取任何命令参数值之前进行。
	flag.Parse()
	fmt.Printf("Hello, %s!\n", name)
}
```

```shell
$ go run demo01.go -name="小明"
运行init函数....
运行main函数.....
Hello, 小明!
$
```

#### （6）查看源码文件的参数说明

```shell
$ go run demo01.go --help
运行init函数....
运行main函数.....
Usage of /var/folders/hl/xg2mgr812fl0gnd4nz25llh00000gn/T/go-build1167242149/b001/exe/demo01:
  -name string
    	The greeting object. (default "everyone")
$
```

其中`/var/folders/hl/xg2mgr812fl0gnd4nz25llh00000gn/T/go-build1167242149/b001/exe/demo01` 是`go run` 命令构建上述命令源码文件时生成的可执行文件的完整路径。

如果先构建，在运行生成的可执行命令文件：

```shell
$ go build demo01.go
bogon:exercise01 lifei$ ll
total 3816
drwxr-xr-x  4 lifei  staff      128 11 12 19:28 ./
drwxr-xr-x  3 lifei  staff       96 11 12 18:37 ../
-rwxr-xr-x  1 lifei  staff  1949088 11 12 19:28 demo01*
-rw-r--r--  1 lifei  staff     1125 11 12 19:23 demo01.go
$ ./demo01 --help
运行init函数....
运行main函数.....
Usage of ./demo01:
  -name string
    	The greeting object. (default "everyone")
$
```

#### （7）自定义源码文件的参数说明

方案一：通过对`flag.Usage`变量进行赋值。

> 对`flag.Usage` 变量的赋值必须在调用`flag.Parse`函数之前。

```go
func main() {
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage of %s:\n", "question")
		flag.PrintDefaults()
	}
	fmt.Println("运行main函数.....")
	// 用于真正解析命令参数，并把它们的值赋给相应的变量
	// 该函数的调用必须放在所有命令参数存储载体的声明（这里是对变量name的声明）和设置（这里是falg.StringVar函数的调度）之后，
	// 并且在读取任何命令参数值之前进行。
	flag.Parse()
	fmt.Printf("Hello, %s!\n", name)
}
```

```shell
$ go run demo02.go --help
运行init函数....
运行main函数.....
Usage of question:
  -name string
    	The greeting object. (default "everyone")
$
```

方案二：

```go
func init() {
	fmt.Println("运行init函数....")
	// 自定义源码文件的参数说明 方案一：
	// flag.Usage = func() {
	// 	fmt.Fprintf(os.Stderr, "Usage of %s:\n", "question")
	// 	flag.PrintDefaults()
	// }

	// 自定义源码文件的参数说明 方案二：
	flag.CommandLine = flag.NewFlagSet("", flag.ExitOnError)
	flag.CommandLine.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage of %s:\n", "question")
		flag.PrintDefaults()
	}
  
  //......
}
```

方案三：使用定义的私有容器

```go
package main

import (
	"flag" // go 语言标准库中的一个代码包
	"fmt"
	"os"
)

var name string

// 创建一个私有的命令容器
var cmdLine = flag.NewFlagSet("question", flag.ExitOnError)

func init() {
	fmt.Println("运行init函数....")
	// 自定义源码文件的参数说明 方案一：
	// flag.Usage = func() {
	// 	fmt.Fprintf(os.Stderr, "Usage of %s:\n", "question")
	// 	flag.PrintDefaults()
	// }

	// 自定义源码文件的参数说明 方案二：
	// flag.CommandLine = flag.NewFlagSet("", flag.ExitOnError)
	// flag.CommandLine.Usage = func() {
	// 	fmt.Fprintf(os.Stderr, "Usage of %s:\n", "question")
	// 	flag.PrintDefaults()
	// }

	// flag 接收四个参数
	//     第一个参数： 用于存储该命令参数值的地址；
	//     第二个参数： 用于指定该命令参数的命令；
	//     第三个参数： 指定在未追加该命令参数时的默认值，这里是everyone；
	//     第四个参数： 该命令参数的简要说明
	// flag.String()  会直接返回一个已经分配好的用于存储命令参数值的地址。
	// var name = flag.String("name", "everyone", "The greeting object.")
	// flag.StringVar(&name, "name", "everyone", "The greeting object.")

	// 使用自定义私有的命令容器
	cmdLine.StringVar(&name, "name", "everyone", "The greeting object.")

}

func main() {

	fmt.Println("运行main函数.....")
	// 用于真正解析命令参数，并把它们的值赋给相应的变量
	// 该函数的调用必须放在所有命令参数存储载体的声明（这里是对变量name的声明）和设置（这里是falg.StringVar函数的调度）之后，
	// 并且在读取任何命令参数值之前进行。
	// flag.Parse()
	// 使用自定义私有的命令容器
	cmdLine.Parse(os.Args[1:])
	fmt.Printf("Hello, %s!\n", name)
}
```

#### （8）思考题

1. 默认情况下，我们可以让命令源码文件接受哪些类型的参数值？
2. 我们可以把自定义的数据类型作为参数值的类型吗？如果可以，怎样做？

### 3.2 库源码文件

#### （1）特点

专门用于放置可供其他代码使用的程序实体。

#### （2）构建

构建的作用在于检查和验证。

构建后只生成临时文件：

- 在操作系统的临时目录；
- 开发者一般可以不关心；

#### （3）安装

安装后生成归档文件：

- 扩展名为`.a`的文件；
- 即为静态链接库文件；

生成位置在当前工作区的pkg子目录。

#### （4）深入库源码文件一：将库代码文件放在相同代码包、代码包的声明规则

```shell
# 设置工作区,多个工作区用逗号分隔
$ go env -w GOPATH="/Users/lifei/go:/Users/lifei/Documents/workspace/githubRepositoies/gowp/projects/go-core-example"
$
```

项目目录结构：

```java
$ tree go-core-example/
go-core-example/
└── src
    ├── article2
    │   └── exercise01
    │       ├── demo01.go
    │       └── demo02.go
    └── article3
        └── q1
            ├── demo01.go
            └── demo01_lib.go
```

`article3/q1/demo01.go`

```go
package main

import (
	"flag"
)

var name string

func init() {
	flag.StringVar(&name, "name", "everyone", "The greeting object.")
}

func main() {
	flag.Parse()
	hello(name)
}

```

`article3/q1/demo01_lib.go`

```go
package main

import (
	"fmt"
)

func hello(name string) {
	fmt.Println(name)
}
```

运行方式一：

```shell
$ cd go-core-example/src/article3/q1/
$ go run demo01.go demo01_lib.go
everyone
$
```

运行方式二：

```shell
$ go build article3/q1
$ ll
total 3808
drwxr-xr-x  5 lifei  staff      160 11 12 23:10 ./
drwxr-xr-x  3 lifei  staff       96 11 12 22:39 ../
drwxr-xr-x  3 lifei  staff       96 11 12 22:36 article2/
drwxr-xr-x  3 lifei  staff       96 11 12 22:36 article3/
-rwxr-xr-x  1 lifei  staff  1949088 11 12 23:10 q1*
$ ./q1
everyone
$
```

代码包的声明规则：

- 同一个目录下的源码文件的代码包声明语句要一致；

  如果目录中有命令源码文件，那么其它种类的源码文件也应该声明属于main包。

- 源码文件声明的代码包的名称可以与其所在的目录的名称不同。在针对代码包进行构建时，生成的结果文件的主名称与其父目录的名称一致。

#### （5）将库代码文件放到其它的代码包

```shell
$ tree article3/q2/
article3/q2/
├── demo02.go
└── lib
    └── demo02_lib.go

1 directory, 2 files
$
```

`article3/q2/lib/demo02_lib.go`

```go
package lib2 // 第一个改动， 把 main 改为 lib2。（故意让声明的包名和所在的目录名称不同）

import (
	"fmt"
)

// 第二个改动， 把首字母小写的 hello 改为 首字母大写的 Hello
func Hello(name string) {
	fmt.Println(name)
}
```

在构建或安装这个代码包的时候，提供给go 命令的路径应该是目录的相对路径：

```shell
$ go install article3/q2/lib/
$ tree go-core-example/pkg
go-core-example/pkg
└── darwin_amd64
    └── article3
        └── q2
            └── lib.a

3 directories, 1 file
$
```

其中`darwin_amd64`就是平台相关目录。

`article3/q2/demo02.go`：

```go
package main

import (
	lib2 "article3/q2/lib"  // 代码包和目录名不一致时的写法。
	"flag"
)

var name string

func init() {
	flag.StringVar(&name, "name", "everyone", "The greeting object.")
}

func main() {
	flag.Parse()
	// hello(name)
	lib2.Hello(name)
}
```

还可以将库源码文件的代码包名称和目录名一致：`article3/q2/lib/demo02_lib.go`

```go
// package lib2 // 第一个改动， 把 main 改为 lib2。（故意让声明的包名和所在的目录名称不同）
package lib // 为了不让代码包的使用者产生困惑，我们总是应该让声明的包名与其父目录的名称一致

import (
	"fmt"
)

// 第二个改动， 把首字母小写的 hello 改为 首字母大写的 Hello
func Hello(name string) {
	fmt.Println(name)
}
```

此时：`article3/q2/demo02.go`：

```go
package main

import (
	// lib2 "article3/q2/lib"
	"article3/q2/lib"
	"flag"
)

var name string

func init() {
	flag.StringVar(&name, "name", "everyone", "The greeting object.")
}

func main() {
	flag.Parse()
	// hello(name)
	// lib2.Hello(name)
	lib.Hello(name)
}
```

当代码包和目录名称不一致的时候，容易出现的错误是（解决方案就是上面两种）：

```shell
$ go run demo02.go
# command-line-arguments
./demo02.go:4:2: imported and not used: "article3/q2/lib" as lib2
./demo02.go:17:2: undefined: lib
$
```

#### （6）GO语言中对程序实体访问权限的规则

- 简单规则：

名称首字母大写的程序实体才可以被当前包外的代码引用，否则它就只能被当前包内的其他代码引用。

通过名称，Go语言自然地把程序实体的访问权限划分为了包级私有的和公开的。

- 模块级私有

在Go 1.5 及后续版本，可以通过internal代码包让程序实体仅仅能被当前模块中的其他代码引用。

具体规则是，internal代码包中声明的公开程序实体仅能被该代码包的直接父包及其子包中的代码引用。当然，引用前需要先导入这个internal包，对于其他代码包，导入该internal包都是非法的，无法通过编译。

#### （7）思考题

1. 如果你需要导入两个代码包，而这两个代码包的导入路径的最后一级是相同的，比如：dep/lib/flag和flag，那么会产生冲突吗？
2. 如果会产生冲突，那么怎样解决这种冲突，有几种方式？



### 3.3 测试源码文件

#### （1）功能测试源码文件

- 测试函数名：`TestXXX`
- 测试函数签名：`(t *testing.T)`

#### （2）性能（基准）测试源码文件

- 测试函数名：`BenchmarkXXX`
- 测试函数签名：`(b *testing.B)`

#### （3）示例（样本）测试源码文件

- 测试函数名：`ExampleXXX`
- 测试函数签名：没有硬性要求
- 测试函数期望输出：
  - 放置在函数末尾
  - 用注释行表示，例如：`// Output: xxx`

