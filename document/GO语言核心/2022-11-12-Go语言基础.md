# Go语言基础

[toc]

## 一、说明

下面是一些参考资料：

- [Go官网](https://golang.google.cn/)

- [Go语言规范文档](https://golang.google.cn/ref/spec)
- [Go官方命令文档页面](https://golang.google.cn/cmd/go/)
- [Go命令命令教程](https://github.com/hyper0x/go_command_tutorial)

```shell
# 在命令行查看go命令的使用
$ go help build
```

- [官网flag命令](https://golang.google.cn/pkg/flag/)

## 二、工作区和GoPath

Go安装成功后，可以通过`go version`验证是否安装成功：

```shell
$ go version
go version go1.18.3 darwin/amd64
$
```

安装的过程，需要配置三个环境变量：

- `GOROOT`：go语言的安装目录；
- `GOPATH`：若干个工作区目录的路径。是我们自定义的工作空间。
- `GOBIN`：Go语言生成的可执行文件的路径。

源码文件：通常存放在某个工作区的src子目录下；

代码包的导入路径：比如`import "github.com/labstack/echo"`, “github.com/labstack/echo”就是导入路径；

归档文件：

命令：`go build`、`go get`

## 三、源码文件

### 3.1 命令源码文件

#### （1）特点

- 独立程序的入口
- 属于main包，包含无参数无结果的main函数；
- main函数执行结束，意味着当前程序运行的结束；
- 同一个代码包中，不要放多个命令源码文件；
- 命令源码文件和苦源码文件也不要放在同一个代码包；

#### （2）构建

构建后生成可执行文件：

- 在命令行中运行的文件；
- 在Windows中就是扩展名为".exe"的文件；
- 在Linux中一般无扩展名；

生成位置在命令执行目录。

#### （3）安装

安装后，形成可执行文件。

生成的位置在当前工作区的bin子目录或GOBIN包含的目录。

#### （4）深入了解命令源码文件

如果一个源码文件声明属于main包，并且有一个无参数声明且无结果声明的main函数，那么它就是命令源码文件。

**对于一个独立的程序，命令源码文件永远只有一个**。

通过构建或安装命令源码文件，生成的可执行文件可以视作“命令”。

#### （5）命令源码文件接收参数

```java
package main

import (
	"flag" // go 语言标准库中的一个代码包
	"fmt"
)

var name string //

func init() {
	fmt.Println("运行init函数....")
	// flag 接收四个参数
	//     第一个参数： 用于存储该命令参数值的地址；
	//     第二个参数： 用于指定该命令参数的命令；
	//     第三个参数： 指定在未追加该命令参数时的默认值，这里是everyone；
	//     第四个参数： 该命令参数的简要说明
	// flag.String()  会直接返回一个已经分配好的用于存储命令参数值的地址。
	// var name = flag.String("name", "everyone", "The greeting object.")
	flag.StringVar(&name, "name", "everyone", "The greeting object.")

}

func main() {
	fmt.Println("运行main函数.....")
	// 用于真正解析命令参数，并把它们的值赋给相应的变量
	// 该函数的调用必须放在所有命令参数存储载体的声明（这里是对变量name的声明）和设置（这里是falg.StringVar函数的调度）之后，
	// 并且在读取任何命令参数值之前进行。
	flag.Parse()
	fmt.Printf("Hello, %s!\n", name)
}
```

```shell
$ go run demo01.go -name="小明"
运行init函数....
运行main函数.....
Hello, 小明!
$
```

#### （6）查看源码文件的参数说明

```shell
$ go run demo01.go --help
运行init函数....
运行main函数.....
Usage of /var/folders/hl/xg2mgr812fl0gnd4nz25llh00000gn/T/go-build1167242149/b001/exe/demo01:
  -name string
    	The greeting object. (default "everyone")
$
```

其中`/var/folders/hl/xg2mgr812fl0gnd4nz25llh00000gn/T/go-build1167242149/b001/exe/demo01` 是`go run` 命令构建上述命令源码文件时生成的可执行文件的完整路径。

如果先构建，在运行生成的可执行命令文件：

```shell
$ go build demo01.go
bogon:exercise01 lifei$ ll
total 3816
drwxr-xr-x  4 lifei  staff      128 11 12 19:28 ./
drwxr-xr-x  3 lifei  staff       96 11 12 18:37 ../
-rwxr-xr-x  1 lifei  staff  1949088 11 12 19:28 demo01*
-rw-r--r--  1 lifei  staff     1125 11 12 19:23 demo01.go
$ ./demo01 --help
运行init函数....
运行main函数.....
Usage of ./demo01:
  -name string
    	The greeting object. (default "everyone")
$
```

#### （7）自定义源码文件的参数说明

方案一：通过对`flag.Usage`变量进行赋值。

> 对`flag.Usage` 变量的赋值必须在调用`flag.Parse`函数之前。

```go
func main() {
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage of %s:\n", "question")
		flag.PrintDefaults()
	}
	fmt.Println("运行main函数.....")
	// 用于真正解析命令参数，并把它们的值赋给相应的变量
	// 该函数的调用必须放在所有命令参数存储载体的声明（这里是对变量name的声明）和设置（这里是falg.StringVar函数的调度）之后，
	// 并且在读取任何命令参数值之前进行。
	flag.Parse()
	fmt.Printf("Hello, %s!\n", name)
}
```

```shell
$ go run demo02.go --help
运行init函数....
运行main函数.....
Usage of question:
  -name string
    	The greeting object. (default "everyone")
$
```

方案二：

```go
func init() {
	fmt.Println("运行init函数....")
	// 自定义源码文件的参数说明 方案一：
	// flag.Usage = func() {
	// 	fmt.Fprintf(os.Stderr, "Usage of %s:\n", "question")
	// 	flag.PrintDefaults()
	// }

	// 自定义源码文件的参数说明 方案二：
	flag.CommandLine = flag.NewFlagSet("", flag.ExitOnError)
	flag.CommandLine.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage of %s:\n", "question")
		flag.PrintDefaults()
	}
  
  //......
}
```

方案三：使用定义的私有容器

```go
package main

import (
	"flag" // go 语言标准库中的一个代码包
	"fmt"
	"os"
)

var name string

// 创建一个私有的命令容器
var cmdLine = flag.NewFlagSet("question", flag.ExitOnError)

func init() {
	fmt.Println("运行init函数....")
	// 自定义源码文件的参数说明 方案一：
	// flag.Usage = func() {
	// 	fmt.Fprintf(os.Stderr, "Usage of %s:\n", "question")
	// 	flag.PrintDefaults()
	// }

	// 自定义源码文件的参数说明 方案二：
	// flag.CommandLine = flag.NewFlagSet("", flag.ExitOnError)
	// flag.CommandLine.Usage = func() {
	// 	fmt.Fprintf(os.Stderr, "Usage of %s:\n", "question")
	// 	flag.PrintDefaults()
	// }

	// flag 接收四个参数
	//     第一个参数： 用于存储该命令参数值的地址；
	//     第二个参数： 用于指定该命令参数的命令；
	//     第三个参数： 指定在未追加该命令参数时的默认值，这里是everyone；
	//     第四个参数： 该命令参数的简要说明
	// flag.String()  会直接返回一个已经分配好的用于存储命令参数值的地址。
	// var name = flag.String("name", "everyone", "The greeting object.")
	// flag.StringVar(&name, "name", "everyone", "The greeting object.")

	// 使用自定义私有的命令容器
	cmdLine.StringVar(&name, "name", "everyone", "The greeting object.")

}

func main() {

	fmt.Println("运行main函数.....")
	// 用于真正解析命令参数，并把它们的值赋给相应的变量
	// 该函数的调用必须放在所有命令参数存储载体的声明（这里是对变量name的声明）和设置（这里是falg.StringVar函数的调度）之后，
	// 并且在读取任何命令参数值之前进行。
	// flag.Parse()
	// 使用自定义私有的命令容器
	cmdLine.Parse(os.Args[1:])
	fmt.Printf("Hello, %s!\n", name)
}
```

#### （8）思考题

1. 默认情况下，我们可以让命令源码文件接受哪些类型的参数值？
2. 我们可以把自定义的数据类型作为参数值的类型吗？如果可以，怎样做？



### 3.2 库源码文件

#### （1）特点

专门用于放置可供其他代码使用的程序实体。

#### （2）构建

构建的作用在于检查和验证。

构建后只生成临时文件：

- 在操作系统的临时目录；
- 开发者一般可以不关心；

#### （3）安装

安装后生成归档文件：

- 扩展名为`.a`的文件；
- 即为静态链接库文件；

生成位置在当前工作区的pkg子目录。

### （4）深入库源码文件

```shell
# 设置工作区,多个工作区用逗号分隔
$ go env -w GOPATH="/Users/lifei/go:/Users/lifei/Documents/workspace/githubRepositoies/gowp/projects/go-core-example"
$
```

项目目录结构：

```java
$ tree go-core-example/
go-core-example/
└── src
    ├── article2
    │   └── exercise01
    │       ├── demo01.go
    │       └── demo02.go
    └── article3
        └── q1
            ├── demo01.go
            └── demo01_lib.go
```

`article3/q1/demo01.go`

```go
package main

import (
	"flag"
)

var name string

func init() {
	flag.StringVar(&name, "name", "everyone", "The greeting object.")
}

func main() {
	flag.Parse()
	hello(name)
}

```

`article3/q1/demo01_lib.go`

```go
package main

import (
	"fmt"
)

func hello(name string) {
	fmt.Println(name)
}
```

运行方式一：

```shell
$ cd go-core-example/src/article3/q1/
$ go run demo01.go demo01_lib.go
everyone
$
```

运行方式二：

```shell
$ go build article3/q1
$ ll
total 3808
drwxr-xr-x  5 lifei  staff      160 11 12 23:10 ./
drwxr-xr-x  3 lifei  staff       96 11 12 22:39 ../
drwxr-xr-x  3 lifei  staff       96 11 12 22:36 article2/
drwxr-xr-x  3 lifei  staff       96 11 12 22:36 article3/
-rwxr-xr-x  1 lifei  staff  1949088 11 12 23:10 q1*
$ ./q1
everyone
$
```



### 3.3 测试源码文件

#### （1）功能测试源码文件

- 测试函数名：`TestXXX`
- 测试函数签名：`(t *testing.T)`

#### （2）性能（基准）测试源码文件

- 测试函数名：`BenchmarkXXX`
- 测试函数签名：`(b *testing.B)`

#### （3）示例（样本）测试源码文件

- 测试函数名：`ExampleXXX`
- 测试函数签名：没有硬性要求
- 测试函数期望输出：
  - 放置在函数末尾
  - 用注释行表示，例如：`// Output: xxx`

