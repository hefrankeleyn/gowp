# Go语言基础

[toc]

## 一、说明

下面是一些参考资料：

- [Go官网](https://golang.google.cn/)

- [Go语言规范文档](https://golang.google.cn/ref/spec)
- [Go官方命令文档页面](https://golang.google.cn/cmd/go/)
- [Go包参考](https://pkg.go.dev/)
- [类型转化](https://golang.google.cn/ref/spec#Conversions)
- [Go命令命令教程](https://github.com/hyper0x/go_command_tutorial)

```shell
# 在命令行查看go命令的使用
$ go help build
```

- [官网flag命令](https://golang.google.cn/pkg/flag/)
- [别名类型](https://go.googlesource.com/proposal/+/master/design/18130-type-alias.md)

示例代码：

- [go-core-example](https://github.com/hefrankeleyn/gowp/tree/main/projects/go-core-example)



- [Unicode标准](https://home.unicode.org/)

## 二、工作区和GoPath

Go安装成功后，可以通过`go version`验证是否安装成功：

```shell
$ go version
go version go1.18.3 darwin/amd64
$
```

安装的过程，需要配置三个环境变量：

- `GOROOT`：go语言的安装目录；
- `GOPATH`：若干个工作区目录的路径。是我们自定义的工作空间。
- `GOBIN`：Go语言生成的可执行文件的路径。

源码文件：通常存放在某个工作区的src子目录下；

代码包的导入路径：比如`import "github.com/labstack/echo"`, “github.com/labstack/echo”就是导入路径；

归档文件：

命令：`go build`、`go get`

## 三、源码文件

### 3.1 命令源码文件

#### （1）特点

- 独立程序的入口
- 属于main包，包含无参数无结果的main函数；
- main函数执行结束，意味着当前程序运行的结束；
- 同一个代码包中，不要放多个命令源码文件；
- 命令源码文件和苦源码文件也不要放在同一个代码包；

#### （2）构建

构建后生成可执行文件：

- 在命令行中运行的文件；
- 在Windows中就是扩展名为".exe"的文件；
- 在Linux中一般无扩展名；

生成位置在命令执行目录。

#### （3）安装

安装后，形成可执行文件。

生成的位置在当前工作区的bin子目录或GOBIN包含的目录。

#### （4）深入了解命令源码文件

如果一个源码文件声明属于main包，并且有一个无参数声明且无结果声明的main函数，那么它就是命令源码文件。

**对于一个独立的程序，命令源码文件永远只有一个**。

通过构建或安装命令源码文件，生成的可执行文件可以视作“命令”。

#### （5）命令源码文件接收参数

```java
package main

import (
	"flag" // go 语言标准库中的一个代码包
	"fmt"
)

var name string //

func init() {
	fmt.Println("运行init函数....")
	// flag 接收四个参数
	//     第一个参数： 用于存储该命令参数值的地址；
	//     第二个参数： 用于指定该命令参数的命令；
	//     第三个参数： 指定在未追加该命令参数时的默认值，这里是everyone；
	//     第四个参数： 该命令参数的简要说明
	// flag.String()  会直接返回一个已经分配好的用于存储命令参数值的地址。
	// var name = flag.String("name", "everyone", "The greeting object.")
	flag.StringVar(&name, "name", "everyone", "The greeting object.")

}

func main() {
	fmt.Println("运行main函数.....")
	// 用于真正解析命令参数，并把它们的值赋给相应的变量
	// 该函数的调用必须放在所有命令参数存储载体的声明（这里是对变量name的声明）和设置（这里是falg.StringVar函数的调度）之后，
	// 并且在读取任何命令参数值之前进行。
	flag.Parse()
	fmt.Printf("Hello, %s!\n", name)
}
```

```shell
$ go run demo01.go -name="小明"
运行init函数....
运行main函数.....
Hello, 小明!
$
```

#### （6）查看源码文件的参数说明

```shell
$ go run demo01.go --help
运行init函数....
运行main函数.....
Usage of /var/folders/hl/xg2mgr812fl0gnd4nz25llh00000gn/T/go-build1167242149/b001/exe/demo01:
  -name string
    	The greeting object. (default "everyone")
$
```

其中`/var/folders/hl/xg2mgr812fl0gnd4nz25llh00000gn/T/go-build1167242149/b001/exe/demo01` 是`go run` 命令构建上述命令源码文件时生成的可执行文件的完整路径。

如果先构建，在运行生成的可执行命令文件：

```shell
$ go build demo01.go
bogon:exercise01 lifei$ ll
total 3816
drwxr-xr-x  4 lifei  staff      128 11 12 19:28 ./
drwxr-xr-x  3 lifei  staff       96 11 12 18:37 ../
-rwxr-xr-x  1 lifei  staff  1949088 11 12 19:28 demo01*
-rw-r--r--  1 lifei  staff     1125 11 12 19:23 demo01.go
$ ./demo01 --help
运行init函数....
运行main函数.....
Usage of ./demo01:
  -name string
    	The greeting object. (default "everyone")
$
```

#### （7）自定义源码文件的参数说明

方案一：通过对`flag.Usage`变量进行赋值。

> 对`flag.Usage` 变量的赋值必须在调用`flag.Parse`函数之前。

```go
func main() {
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage of %s:\n", "question")
		flag.PrintDefaults()
	}
	fmt.Println("运行main函数.....")
	// 用于真正解析命令参数，并把它们的值赋给相应的变量
	// 该函数的调用必须放在所有命令参数存储载体的声明（这里是对变量name的声明）和设置（这里是falg.StringVar函数的调度）之后，
	// 并且在读取任何命令参数值之前进行。
	flag.Parse()
	fmt.Printf("Hello, %s!\n", name)
}
```

```shell
$ go run demo02.go --help
运行init函数....
运行main函数.....
Usage of question:
  -name string
    	The greeting object. (default "everyone")
$
```

方案二：

```go
func init() {
	fmt.Println("运行init函数....")
	// 自定义源码文件的参数说明 方案一：
	// flag.Usage = func() {
	// 	fmt.Fprintf(os.Stderr, "Usage of %s:\n", "question")
	// 	flag.PrintDefaults()
	// }

	// 自定义源码文件的参数说明 方案二：
	flag.CommandLine = flag.NewFlagSet("", flag.ExitOnError)
	flag.CommandLine.Usage = func() {
		fmt.Fprintf(os.Stderr, "Usage of %s:\n", "question")
		flag.PrintDefaults()
	}
  
  //......
}
```

方案三：使用定义的私有容器

```go
package main

import (
	"flag" // go 语言标准库中的一个代码包
	"fmt"
	"os"
)

var name string

// 创建一个私有的命令容器
var cmdLine = flag.NewFlagSet("question", flag.ExitOnError)

func init() {
	fmt.Println("运行init函数....")
	// 自定义源码文件的参数说明 方案一：
	// flag.Usage = func() {
	// 	fmt.Fprintf(os.Stderr, "Usage of %s:\n", "question")
	// 	flag.PrintDefaults()
	// }

	// 自定义源码文件的参数说明 方案二：
	// flag.CommandLine = flag.NewFlagSet("", flag.ExitOnError)
	// flag.CommandLine.Usage = func() {
	// 	fmt.Fprintf(os.Stderr, "Usage of %s:\n", "question")
	// 	flag.PrintDefaults()
	// }

	// flag 接收四个参数
	//     第一个参数： 用于存储该命令参数值的地址；
	//     第二个参数： 用于指定该命令参数的命令；
	//     第三个参数： 指定在未追加该命令参数时的默认值，这里是everyone；
	//     第四个参数： 该命令参数的简要说明
	// flag.String()  会直接返回一个已经分配好的用于存储命令参数值的地址。
	// var name = flag.String("name", "everyone", "The greeting object.")
	// flag.StringVar(&name, "name", "everyone", "The greeting object.")

	// 使用自定义私有的命令容器
	cmdLine.StringVar(&name, "name", "everyone", "The greeting object.")

}

func main() {

	fmt.Println("运行main函数.....")
	// 用于真正解析命令参数，并把它们的值赋给相应的变量
	// 该函数的调用必须放在所有命令参数存储载体的声明（这里是对变量name的声明）和设置（这里是falg.StringVar函数的调度）之后，
	// 并且在读取任何命令参数值之前进行。
	// flag.Parse()
	// 使用自定义私有的命令容器
	cmdLine.Parse(os.Args[1:])
	fmt.Printf("Hello, %s!\n", name)
}
```

#### （8）思考题

1. 默认情况下，我们可以让命令源码文件接受哪些类型的参数值？

   参考[falg](https://pkg.go.dev/flag)， Bool、Duration、Float64、Int、Int64、String、UInt

2. 我们可以把自定义的数据类型作为参数值的类型吗？如果可以，怎样做？

### 3.2 库源码文件

#### （1）特点

专门用于放置可供其他代码使用的程序实体。

#### （2）构建

构建的作用在于检查和验证。

构建后只生成临时文件：

- 在操作系统的临时目录；
- 开发者一般可以不关心；

#### （3）安装

安装后生成归档文件：

- 扩展名为`.a`的文件；
- 即为静态链接库文件；

生成位置在当前工作区的pkg子目录。

#### （4）深入库源码文件一：将库代码文件放在相同代码包、代码包的声明规则

```shell
# 设置工作区,多个工作区用逗号分隔
$ go env -w GOPATH="/Users/lifei/go:/Users/lifei/Documents/workspace/githubRepositoies/gowp/projects/go-core-example"
$
```

项目目录结构：

```java
$ tree go-core-example/
go-core-example/
└── src
    ├── article2
    │   └── exercise01
    │       ├── demo01.go
    │       └── demo02.go
    └── article3
        └── q1
            ├── demo01.go
            └── demo01_lib.go
```

`article3/q1/demo01.go`

```go
package main

import (
	"flag"
)

var name string

func init() {
	flag.StringVar(&name, "name", "everyone", "The greeting object.")
}

func main() {
	flag.Parse()
	hello(name)
}

```

`article3/q1/demo01_lib.go`

```go
package main

import (
	"fmt"
)

func hello(name string) {
	fmt.Println(name)
}
```

运行方式一：

```shell
$ cd go-core-example/src/article3/q1/
$ go run demo01.go demo01_lib.go
everyone
$
```

运行方式二：

```shell
$ go build article3/q1
$ ll
total 3808
drwxr-xr-x  5 lifei  staff      160 11 12 23:10 ./
drwxr-xr-x  3 lifei  staff       96 11 12 22:39 ../
drwxr-xr-x  3 lifei  staff       96 11 12 22:36 article2/
drwxr-xr-x  3 lifei  staff       96 11 12 22:36 article3/
-rwxr-xr-x  1 lifei  staff  1949088 11 12 23:10 q1*
$ ./q1
everyone
$
```

代码包的声明规则：

- 同一个目录下的源码文件的代码包声明语句要一致；

  如果目录中有命令源码文件，那么其它种类的源码文件也应该声明属于main包。

- 源码文件声明的代码包的名称可以与其所在的目录的名称不同。在针对代码包进行构建时，生成的结果文件的主名称与其父目录的名称一致。

#### （5）将库代码文件放到其它的代码包

```shell
$ tree article3/q2/
article3/q2/
├── demo02.go
└── lib
    └── demo02_lib.go

1 directory, 2 files
$
```

`article3/q2/lib/demo02_lib.go`

```go
package lib2 // 第一个改动， 把 main 改为 lib2。（故意让声明的包名和所在的目录名称不同）

import (
	"fmt"
)

// 第二个改动， 把首字母小写的 hello 改为 首字母大写的 Hello
func Hello(name string) {
	fmt.Println(name)
}
```

在构建或安装这个代码包的时候，提供给go 命令的路径应该是目录的相对路径：

```shell
$ go install article3/q2/lib/
$ tree go-core-example/pkg
go-core-example/pkg
└── darwin_amd64
    └── article3
        └── q2
            └── lib.a

3 directories, 1 file
$
```

其中`darwin_amd64`就是平台相关目录。

`article3/q2/demo02.go`：

```go
package main

import (
	lib2 "article3/q2/lib"  // 代码包和目录名不一致时的写法。
	"flag"
)

var name string

func init() {
	flag.StringVar(&name, "name", "everyone", "The greeting object.")
}

func main() {
	flag.Parse()
	// hello(name)
	lib2.Hello(name)
}
```

还可以将库源码文件的代码包名称和目录名一致：`article3/q2/lib/demo02_lib.go`

```go
// package lib2 // 第一个改动， 把 main 改为 lib2。（故意让声明的包名和所在的目录名称不同）
package lib // 为了不让代码包的使用者产生困惑，我们总是应该让声明的包名与其父目录的名称一致

import (
	"fmt"
)

// 第二个改动， 把首字母小写的 hello 改为 首字母大写的 Hello
func Hello(name string) {
	fmt.Println(name)
}
```

此时：`article3/q2/demo02.go`：

```go
package main

import (
	// lib2 "article3/q2/lib"
	"article3/q2/lib"
	"flag"
)

var name string

func init() {
	flag.StringVar(&name, "name", "everyone", "The greeting object.")
}

func main() {
	flag.Parse()
	// hello(name)
	// lib2.Hello(name)
	lib.Hello(name)
}
```

当代码包和目录名称不一致的时候，容易出现的错误是（解决方案就是上面两种）：

```shell
$ go run demo02.go
# command-line-arguments
./demo02.go:4:2: imported and not used: "article3/q2/lib" as lib2
./demo02.go:17:2: undefined: lib
$
```

#### （6）GO语言中对程序实体访问权限的规则

- 简单规则：

名称首字母大写的程序实体才可以被当前包外的代码引用，否则它就只能被当前包内的其他代码引用。

通过名称，Go语言自然地把程序实体的访问权限划分为了包级私有的和公开的。

- 模块级私有

在Go 1.5 及后续版本，可以通过internal代码包让程序实体仅仅能被当前模块中的其他代码引用。

具体规则是，internal代码包中声明的公开程序实体仅能被该代码包的直接父包及其子包中的代码引用。当然，引用前需要先导入这个internal包，对于其他代码包，导入该internal包都是非法的，无法通过编译。

```shell
$ tree article3/q3/
article3/q3/
├── demo03.go
└── lib
    ├── demo03_lib.go
    └── internal
        └── internal.go

2 directories, 3 files
$
```

`article3/q3/demo03.go`

```go
package main

import (
	// "article3/q3/lib"
	in "article3/q3/lib/internal"
	"flag"
	"os"
)

var name string

func init() {
	flag.StringVar(&name, "name", "everyone", "The greeting object.")
}

func main() {
	flag.Parse()
	// lib.Hello(name)
	in.Hello(os.Stdout, name)
}
```

```shell
$ go run demo03.go
package command-line-arguments
	demo03.go:5:2: use of internal package article3/q3/lib/internal not allowed
$
```

#### （7）思考题

1. 如果你需要导入两个代码包，而这两个代码包的导入路径的最后一级是相同的，比如：dep/lib/flag和flag，那么会产生冲突吗？

   会冲突。

2. 如果会产生冲突，那么怎样解决这种冲突，有几种方式？

方案一：起别名

```go
package main

import (
	hw_lib1 "article3/q4/hw/lib"
	q4_lib1 "article3/q4/lib"
	"flag"
)

var name string

func init() {
	flag.StringVar(&name, "name", "everyone", "The greeting object.")
}

func main() {
	flag.Parse()
	// lib.Hello(name)
	q4_lib1.Hello(name)
	hw_lib1.Hello(name)
	// in.Hello(os.Stdout, name)
}
```

另外两种方案：引入包前面加"."， 引入包前面加"_"

```go
package main

import (
	. "article3/q4/hw/lib" // 前面加点，可以直接调用里面的函数
	// q4_lib1 "article3/q4/lib"
	_ "article3/q4/lib" // 如果只想引入包，而实际没有调用
	"flag"
)

var name string

func init() {
	flag.StringVar(&name, "name", "everyone", "The greeting object.")
}

func main() {
	flag.Parse()
	Hello(name) // 直接调用函数名，不用加 XXX. 了
	// q4_lib1.Hello(name)
	// hw_lib1.Hello(name)
	// in.Hello(os.Stdout, name)
}
```



### 3.3 测试源码文件

#### （1）功能测试源码文件

- 测试函数名：`TestXXX`
- 测试函数签名：`(t *testing.T)`

#### （2）性能（基准）测试源码文件

- 测试函数名：`BenchmarkXXX`
- 测试函数签名：`(b *testing.B)`

#### （3）示例（样本）测试源码文件

- 测试函数名：`ExampleXXX`
- 测试函数签名：没有硬性要求
- 测试函数期望输出：
  - 放置在函数末尾
  - 用注释行表示，例如：`// Output: xxx`

## 四、程序实体

Go语言中的程序实体包括变量、常量、函数、结构体和接口。

### 4.1 变量

#### （1）声明变量的三种方式

```go
package main

import (
	"flag"
	"fmt"
)

func main() {
	// 变量的第一种声明方式
	// var name string
	// flag.StringVar(&name, "name", "everyone", "The greeting Object")

	// 变量的第二种声明方式, 返回的类型 为 *string
	// var name = flag.String("name", "everyone", "The greeting Object.")

	// 变量的第三种声明方式
	name := flag.String("name", "everyone", "The greeting Object.")
	flag.Parse()
	fmt.Println(*name)
	fmt.Printf("%T\n", name)
}
```

#### （2）Go语言中的类型推断

利用Go语言自身的类型推断。

- [GO表达式](https://golang.google.cn/ref/spec#Expressions)
- [GO表达式语句](https://golang.google.cn/ref/spec#Expression_statements)

这种方式更通用，可以用在任何地方。

GO语言是静态语言，这种类型的确定是在编译器完成的，因此不会对程序运行效率产生任何影响。

#### （3）短变量声明的用法

短变量声明，实际上是Go语言的类型推断再加上一点点语法糖。

**只能在函数体内部使用短变量声明。**

#### （4）变量的重声明

重声明，是再次声明的意思。

变量重声明的前提条件：

- 再次声明时，类型必须与原本的类型相同；
- 只会发生在一个代码块中；
- 只在使用短变量声明时才会发生；
- 被“声明并赋值”的变量必须是多个，并且其中至少有一个是新的变量；

```go
package main

import (
	"fmt"
	"io"
	"os"
)

func main() {
	var err error
	n, err := io.WriteString(os.Stdout, "Hello, everyone!\n") // 这里对`err`进行了重声明。
	if err != nil {
		fmt.Printf("Error: %v\n", err)
	}
	fmt.Printf("%d byte(s) were written.\n", n)
}
```

#### （5）思考题

如果与当前的变量重名的是外层代码块中的变量，那么这意味着什么？

意味着，当前变量覆盖外层变量。

### 4.2 实体访问权限

#### （1）变量名与外层变量名重名

```go
package main

import (
	"fmt"
)

var name = "package"

func main() {
	name := "function"
	{
		name := "inner"
		fmt.Println(name)
	}
	fmt.Println(name)
}
```

#### （2）重名变量与变量的重声明

1. 变量重声明中的变量一定是在某一个代码块内的。注意，这里的“某一个代码块内”并不包含它的任何子代码块，否则就变成了“多个代码块之间”。而可重名变量指的正是在多个代码块之间由相同的标识符代表的变量。
2. 变量重声明是对同一个变量的多次声明，这里的变量只有一个。而可重名变量中涉及的变量肯定是有多个的。
3. 不论对变量重声明多少次，其类型必须始终一致，具体遵从它第一次被声明时给定的类型。而**可重名变量之间不存在类似的限制，它们的类型可以是任意的**。
4. 如果可重名变量所在的代码块之间，存在直接或间接的嵌套关系，那么它们之间一定会存在“屏蔽”的现象。但是这种现象绝对不会在变量重声明的场景下出现。

```go
package main

import "fmt"

var container = []string{"one", "two", "three"}

func main() {
	container := map[int]string{0: "one", 2: "two", 3: "three"}
	fmt.Println(container)
}
```

#### （3）思考题

通过`import . XXX`这种导入代码包的方式。如果通过这种方式导入的代码包中的变量与当前代码包中的变量重名了，那么 Go 语言是会把它们当做“可重名变量”看待还是会报错呢？

> 如果都是全局的变量，会报重复声明，如果只是在函数体重新声明，作用域不一样，会出现屏蔽现象。

### 4.3 判断变量的类型

#### （1）判断类型

语法： x.(T) ， 这里的x必须是接口类型，具体是哪个接口无所谓。

- interface{} 代表，空接口，任何类型都能很方便地转换成空接口。

```go
package main

import (
	"fmt"
)

var container = []string{"aa", "bb", "cc"}

func main() {
	container := map[int]string{0: "aa", 1: "bb", 2: "cc"}
	// 第一种判断类型的方法：
	// 语法 x.(T) ， 这里的x必须是接口类型，具体是哪个接口无所谓。
	// interface{} 代表，空接口，任何类型都能很方便地转换成空接口。
	// interface{}(container) 把 container 转为空接口类型
	// .([]string) 判断前面的类型是否为切片类型
	// 这里的ok也可以没有，如果没有，判断不通过会引发异常
	// value 是类型转换之后都值；ok 是断言是否成功
	vlaue, ok := interface{}(container).([]string)
	fmt.Printf("%q, %%, %t\n", vlaue, ok)
	fmt.Printf("这个元素是：%q\n", container)

	// 第二种判断类型的方法
	val, err := getElement(container)
	fmt.Printf("%q, %v", val, err)
}

func getElement(containerI interface{}) (elem string, err error) {
	switch t := containerI.(type) {
	case []string:
		elem = t[1]
	case map[int]string:
		elem = t[1]
	default:
		err = fmt.Errorf("不支持的类型： %T", containerI)
		return
	}
	return
}

```

一对不包裹任何东西的花括号，除了可以代表空的代码块之外，还可以用于表示不包含任何内容的数据结构（或者说数据类型）。

#### （2）类型转化

`T(x)`

#### （3）别名类型、类型再定义与潜在类型

- `type MyString=string` ， MyString 就是string的别名类型，它们是相同的类型；
- `type MyString string` 
