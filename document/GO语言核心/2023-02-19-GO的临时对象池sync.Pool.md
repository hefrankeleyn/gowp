# GO的临时对象池sync.Pool

[toc]

## 一、临时对象池：sync.Pool

sync.Pool 类型可以被称为临时对象池，它的值可以被用来存储临时的对象。

> sync.Pool 也属于结构体类型，它的值被真正使用过之后，不应该再被复制了。

### 1.1 临时对象的特点

- 不需要持久使用的某一类值。

  > 这类值对程序来说可有可无，但如果有的话明显会更好。它们的创建和销毁可以再任何时候发生，并且完全不影响到程序的功能。

- 它们也是无需被区分的。

  > 其中的任何一个值都可以替换另一个。

### 1.2 临时对象池的用途

临时对象池的主要用途是：当作针对某类数据的缓存来用。

### 1.3 sync.Pool 的用法

sync.Pool类型只有两个方法——Put和Get。

- Put用于在当前的池中存放临时对象，它接受一个`interface{}`类型的参数；

- Get用于从当前的池中获取临时对象，它返回一个`interface{}` 类型的参数；

  > Get方法可能会从当前的池中删除掉任何一个值，然后把这个值作为结果返回。如果此时当前的池中没有任何值，那么这个方法就会使用当前池的New字段创建一个新值，并直接将其返回。

  **该函数的结果值，并不会被存入当前的临时对象池中，而是直接返回给Get方法的调用方。**

`sync.Pool`类型的New字段代表着创建临时对象的函数。

> New字段的类型是没有任何参数但有唯一结果的函数类型，即：func() interface{}。
>
> 这个函数是Get方法最后的临时对象获取手段。

`sync.Pool`的New字段的实际值需要在初始化临时对象池的时候给定。否则，我们调用它的Get方法的时候就有可能会得到nil。

## 二、临时对象池中的值会被及时清理掉

为什么说临时对象池中的值会被及时清理掉？

因为，Go语言运行时系统中的垃圾回收器，在每次执行之前，都会对已创建的临时对象池中的值进行全面的清除。

### 2.1 池清理函数

sync包在被初始化的时候，会向Go语言运行时系统注册一个函数，这个函数的功能就是清理所以已创建的临时对象池中的值。我们把这个函数称为池清理函数。

一旦池清理函数被注册到Go语言运行时系统，Go语言运行系统在每次执行垃圾回收之前，都会执行池清理函数。

### 2.2 池汇总列表

在sync包中有一个包级私有的全局变量，这个变量代表了当前程序中使用的所有临时对象池的汇总，它是元素类型为`*shnc.Pool`的切片。我们可以称之为池汇总列表。

通常，在一个临时对象池的Put方法和Get方法第一次被调用的时候，这个池就会添加到池汇总列表中。**正因为如此，池清理函数总能访问到所有正在被真正使用的临时对象池。**

### 2.3 临时对象池存储值所用的数据结构

在临时对象池中，有一个多层的数据结构。

> 正是由于它的存在，临时对象池才能够非常高校的存储大量的值。

（1）本地池列表

这个数据结构的顶层，我们称为**本地池列表**，确切地说，它是一个数组。这个数组的长度总是与Go语言调度器中的P的数量相同。

> 在Go语言调度器中，P是processor的缩写，它是一种可以承载若干个G、且能使G适时地与M进行对接，并得到真正运行的中介。
>
> 这里的G时goroutine缩写。而M是machine的缩写，machine代表系统级的线程。
>
> 正是由于P的存在，G和M才能够进行灵活、高校地配对，并实现强大的并发模型。

（2）本地池列表的长度与P的数量相同

P存在的一个重要原因是分散并发程序的执行压力，而让临时对象池中的本地池列表长度与P数量相同的主要原因也是分散压力。这里的压力是存储和性能两方面。

（3）本地池列表中的每个**本地池**

本地池列表中的每个本地池都包含三个字段：存储私有临时对象的字段private、代表共享临时对象列表字段shared、以及一个sync.Mutex类型的嵌入字段。

（4）本地池与G、P的关系

每个本地池都对应一个P。一个goroutine要想真正的运行，就必须先与某个P产生关联。也就是说，一个正在运行的goroutine必然会关联某个P。

在程序调用临时对象池的Put和Get方法的时候，总是依据当前的goroutine关联的那个P的ID，选取与之对应的本地池。

### 2.4 临时对象池如何利用内部数据结构来存取值

（1）共享临时对象列表：shared字段的可访问范围

一个本地池的shared字段原则上可以被任何goroutine中的代码访问到。不论这个goroutine关联的是哪一个P。这也是我们把它叫做共享临时对象列表的原因。

（2）private字段

一个本地池的private字段，只可能被与之对应的那个P所关联的goroutine中的代码访问到。所以可以说，它是P级私有的。

（3）Put方法

临时对象池的Put方法总会试图把新的临时对象，存储到对应的本地池的private字段中，以便获取临时对象的时候，可以快读拿到一个可用的值。**只有当这个private字段已经存在某个值当时候，该方法才会访问本地池的shared字段。**

临时对象池的Put方法，它一旦发现对应的本地池的private字段以存在值，就会去访问这个本地池的shared字段。由于shared字段是共享的，所以此时必须受到互斥锁的保护。这时本地池的嵌入的类型为sync.Mutex的字段就派上用场了。

（4）Get方法

相应的，临时对象池的Get方法，总会试图从对应的本地池的private字段处获取一个临时对象。只有当这个private字段的值为nil时，它才会在互斥锁的保护下访问本地池的shared字段（共享临时对象列表），把共享临时对象列表中的最有一个元素值取出并作为结果。

不过这时共享临时对象列表也可能是空的，Get方法会去访问当前的临时对象池中的所有本地池，它会去逐个搜索它们的共享临时对象列表。

这样如果仍无法获取可用的临时对象，Get方法就会使出最后的手段——调用可创建临时对象的那个函数。这个函数是由临时对象池的New字段代表，如果这个字段的值为nil，那么Get方法也只能返回nil了。

### 2.5 池清理函数的作用机理

池清理函数会遍历池汇总列表。对于其中的每一个临时对象池，它都会将池中所有的私有临时对象（private字段）和共享临时列表（shared字段）都置为nil，然后再把这个池中的所有本地池列表都销毁掉。

最后，池清理函数会把池汇总列表重制为空的切片。如此以来，池清理函数就把池汇总列表重置为空的切片。池中的临时对象也就被清除干净了。

## 三、示例

```go
package main

import (
	"bytes"
	"fmt"
	"io"
	"sync"
)

// bufPool 代表存放数据缓冲区的临时对象池
var bufPool sync.Pool

// Buffer 代表一个简单的数据块缓冲区的接口
type Buffer interface {
	// Delimiter 用于获取数据块之间的定界符
	Delimiter() byte
	// write 用于写一个数据块
	Write(contents string) (err error)
	// Read 用于读一个数据块
	Read() (contexts string, err error)
	// Free 用于释放当前的缓冲区
	Free()
}

// myBuffer 代表了数据块缓冲区的一种实现
type myBuffer struct {
	buf       bytes.Buffer
	delimiter byte
}

func (b *myBuffer) Delimiter() byte {
	return b.delimiter
}

func (b *myBuffer) Write(contexts string) (err error) {
	if _, err = b.buf.WriteString(contexts); err != nil {
		return
	}
	return b.buf.WriteByte(b.delimiter)
}

func (b *myBuffer) Read() (contexts string, err error) {
	return b.buf.ReadString(b.delimiter)
}

func (b *myBuffer) Free() {
	bufPool.Put(b)
}

// delimiter 代表预定义的定界符
var delimiter = byte('\n')

// GetBuffer 用于获取一个数据块缓冲区
func GetBuffer() Buffer {
	return bufPool.Get().(Buffer)
}

func init() {
	bufPool = sync.Pool{
		New: func() any {
			return &myBuffer{delimiter: delimiter}
		},
	}
}

func main() {
	buf := GetBuffer()
	defer buf.Free()
	// buf := &myBuffer{delimiter: delimiter}
	buf.Write("一个池是一个临时对象集合，这些对象能够单独的保存和释放。")
	buf.Write("一个池让多个goroutine同时使用也是安全的。")
	buf.Write("一个池在第一次被使用之后，不能被拷贝")

	fmt.Println("数据块在缓冲区中")
	for {
		block, err := buf.Read()
		if err != nil {
			if err == io.EOF {
				break
			}
			panic(fmt.Errorf("未知的错误：%s", err))
		}
		fmt.Print(block)
	}
}
```

> 作者: 你每次从这个 sync.Pool 当中，用 Get 方法获取 Buffer，都会得到一个存在于该池中的、已就绪的 Buffer 实例，而 Put 一个 Buffer 实例，则会把它归还给这个 sync.Pool。这是这里演示的 sync.Pool 的基本用法。 
>
> 这里为了简单和直观，我就没有划分成两个代码包，你可以想象一下，bufPool 变量、Buffer 接口、myBuffer 结构体、GetBuffer 函数同在某一个代码包里面，而 main 函数则存在于另一个代码包里。如此一来，直接写成 &myBuffer{delimiter: delimiter} ，就等于把内部实现暴露给了外界，这样会在后期造成维护成本的增加，况且 myBuffer 还是包级私有的类型。 
>
> 这里只是一个简单的演示，演示怎样利用 sync.Pool 存储一些可相互替换的同类对象，以供其他程序来高效的获取（Get）和归还（Put）对象。这个 sync.Pool 就是所谓的对象池，其内部实现得非常高效，用法也很简单，不是吗？我们就不用自己实现对象池了，用现成的就好了。 
>
> 在这个示例中，还包含了一些“便捷函数”（如 GetBuffer 函数）和“便捷方法”（如 myBuffer 的 Free 方法），以方便外界更容易的使用这类 Buffer。 
>
> 更具体地说，它隐藏了 bufPool 变量（假设该变量不在 main 函数所在的代码包里），并提供了简单调用一下就能获取一个 Buffer 实例的 GetBuffer 函数，以及用完某个 Buffer 就可以直接在它之上调用的 Free 方法（用于将该 Buffer 实例归还给 bufPool）。 
>
> 总之，这是一种比较好的实现方式，提供给你们参考用的。



