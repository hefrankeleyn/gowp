# GO的Mutex（互斥锁）和RWMutex（读写锁）

[toc]

## 一、竞态条件、临界区、同步工具

### （1）竞态条件

一旦数据被多个线程共享，那么就会产生冲突和争用的情况，这种情况被称为**竞态条件**。这往往会破坏数据的一致性。

同步的用途有两个，一个是避免多线程在同一时刻操作同一个数据块，另一个是协调多线程，以避免它们在同一时刻执行同一个代码块。

### （2）临界区

一个线程在想要访问某一个共享资源的时候，需要先申请对该资源的访问权限，并且只有在申请成功之后，访问才能真正开始。

而当线程对共享资源的访问结束时，它还必须归还对该资源的访问权限，若要再次访问仍需申请。

我们可以说，多个并发运行的线程对这个共享资源的访问是完全串行的，只要一个代码片段需要实现对共享资源的串行化访问，就可以被视为一个**临界区**。由于要访问到资源而必须进入到那个区域。

### （3）同步工具

**临界区**总是受保护的，否则会产生**竞态条件**。施加保护的重要手段之一，就是使用实现了某种同步机制的工具，也称为同步工具。

## 二、互斥量（mutual exclusion，简称mutex）

在Go语言中，可供我们选择的同步工具不少。其中，最重要且最常用的同步工具当属互斥量（mutual exclusion，简称mutex）。

sync包中的Mutex就是与其对应的类型，该类型的值可以被称为互斥量或者互斥锁。

> 一个互斥锁可以被用来保护一个临界区或者一组临界区。我们可以通过它来保证，在同一时刻只有一个goroutine处于该临界区。

为了实现这个保证，每当有goroutine想进入临界区，都要先对它进行锁定，并且，每个goroutine离开临界区，都要及时对它进行解锁。

- 锁定操作：调用互斥锁的Lock方法；
- 解锁操作：调用互斥锁的Unlock方法；

```go
mu.Lock()
_, err := writer.Write([]byte(data))
if err != nil {
 log.Printf("error: %s [%d]", err, id)
}
mu.Unlock()
```

> go run demo01.go -protecting=0

## 三、使用互斥锁的注意事项

### （1）使用互斥锁的注意事项

使用互斥锁的注意事项如下：

1. 不要重复锁定互斥锁；
2. 不要忘记解锁互斥锁，必要时使用defer语句；
3. 不要对尚未锁定或已解锁的互斥锁解锁；
4. 不要在多个函数之间传递互斥锁；

把一个互斥锁同时用在多个地方，不但会让程序变慢，还会大大增加死锁的可能性。

**有GO语言运行时系统自行抛出的panic都属于致命错误，都是无法被恢复的，调用recover函数对他们起不到任何作用。也就是说，一旦产生死锁，程序必然崩溃。**

为了避免这种情况，最简单有效的方法就是让每一个互斥锁都只保护一个临界区或一组相关临界区。在这个前提下，还要注意，就不要重复锁定一个互斥锁，也不要忘记对它的解锁。

> 一个goroutine对某一个互斥锁重复锁定，就意味着它自己锁死自己。

不要忘记解锁的一个重要原因是：**避免重复锁定**。

同样，解锁未锁定的互斥锁会立即引发 panic。

### （2）最保险的做法：使用defer 语句解锁

如果一个流程在锁定了某个互斥锁之后分叉了，或者有被中断的可能，那么就应该使用defer语句来对它进行解锁，而且这样的defer语句应该紧跟在锁定操作之后。这是最保险的一种做法。

### （3）`sync.Mutex`是值类型

Go 语言中的互斥锁是开箱即用的。换句话说，一旦我们声明了一个sync.Mutex类型的变量，就可以直接使用它了。

不过要注意，该类型是一个结构体类型，属于值类型中的一种。把它传给一个函数、将它从函数中返回、把它赋给其他变量、让它进入某个通道都会导致它的副本的产生。

并且，原值和它的副本，以及多个副本之间都是完全独立的，它们都是不同的互斥锁。

## 四、读写锁与互斥锁的异同

### （1）读/写互斥锁

读写锁是读/写互斥锁的简称。在Go语言中，读写锁由`sync.RWMutex`类型的值代表。与`sync.Mutex`类型一样，也是开箱即用。

一个读写锁中，实际包含两个锁，即：读锁和写锁。

> sync.RWMutex类型中的Lock方法和Unlock方法分别用于对写锁进行锁定和解锁，而它的RLock方法和RUnlock方法则分别用于对读锁进行锁定和解锁。

### （2）读写锁规则

1. 在写锁已被锁定的情况下再试图锁定写锁，会阻塞当前的 goroutine。
2. 在写锁已被锁定的情况下试图锁定读锁，也会阻塞当前的 goroutine。
3. 在读锁已被锁定的情况下试图锁定写锁，同样会阻塞当前的 goroutine。
4. 在读锁已被锁定的情况下再试图锁定读锁，并不会阻塞当前的 goroutine。

**多个写操作不能同时进行，写操作和读操作也不能同时进行，但多个读操作却可以同时进行。**

### （3）解锁读写锁

对写锁进行解锁，会唤醒“所有因试图锁定读锁，而被阻塞的 goroutine”，并且，这通常会使它们都成功完成对读锁的锁定。

对读锁进行解锁，只会在没有其他读锁锁定的前提下，唤醒“因试图锁定写锁，而被阻塞的 goroutine”；并且，最终只会有一个被唤醒的 goroutine 能够成功完成对写锁的锁定，其他的 goroutine 还要在原处继续等待。至于是哪一个 goroutine，那就要看谁的等待时间最长了。

与互斥锁类似，解锁“读写锁中未被锁定的写锁”，会立即引发 panic，对于其中的读锁也是如此，并且同样是不可恢复的。，与互斥锁类似，解锁“读写锁中未被锁定的写锁”，会立即引发 panic，对于其中的读锁也是如此，并且同样是不可恢复的。