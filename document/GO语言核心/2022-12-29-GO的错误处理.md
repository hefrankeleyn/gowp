# GO 的错误处理

[toc]

## 一、Go的内建类型error

- error类型其实是一个接口类型，也是GO语言的内建类型；

- 在这个接口类型的声明中只包含了一个方法Error；

  Error方法不接受任何参数，但是会返回一个string类型的结果。

- 可以通过`errors.New(string) error` 方法声明一个error类型的变量；

- 通过模块化的方式生成错误信息，可以使用`fmt.Errorf` 。

   这个方法相当于先调用`fmt.Sprintf`得到确切的错误信息，再调用`errors.New`函数，得到包含错误信息的error类型值。最后返回该值。

使用error的案例：

```go
package main

import (
	"errors"
	"fmt"
)

func echo(request string) (response string, err error) {
	if request == "" {
		err = errors.New("empty request")
		return
	}
	response = fmt.Sprintf("echo: %s", request)
	return
}

func main() {
	for _, request := range []string{"", "hello!"} {
		fmt.Printf("request: %s\n", request)
		resp, err := echo(request)
		if err != nil {
			fmt.Printf("error: %s\n", err)
			continue
		}
		fmt.Printf("response: %s \n", resp)
	}
}
```

## 二、怎么判断一个错误值具体代表那一类错误

1. 对于类型在已知范围内的一系列错误，一般使用类型断言表达式或类型switch语句来判断；
2. 对于已有相应变量且类型相同的一系列错误，一般直接使用判等操作来判断；
3. 对于没有相应变量且类型未知的一系列错误值，只能使用其错误信息的字符串表示形式来判断；

### （1）知道错误类型的所属范围

```go
import (
	"os"
	"os/exec"
)

func underlyingError(err error) error {
	switch errtype := err.(type) {
	case *os.PathError:
		return errtype.Err
	case *os.LinkError:
		return errtype.Err
	case *os.SyscallError:
		return errtype.Err
	case *exec.Error:
		return errtype.Err
	default:
		return err
	}
}
```

### （2）知错错误变量是哪几个值

```go
func knownError(err error) {
	switch err {
	case os.ErrClosed:
		fmt.Println("errClosed")
	case os.ErrInvalid:
		fmt.Println("errInvalid")
	case os.ErrPermission:
		fmt.Println("errPermission")
	}
}
```

