# GO 的错误处理

[toc]

## 一、Go的内建类型error

- error类型其实是一个接口类型，也是GO语言的内建类型；

- 在这个接口类型的声明中只包含了一个方法Error；

  Error方法不接受任何参数，但是会返回一个string类型的结果。

- 可以通过`errors.New(string) error` 方法声明一个error类型的变量；

- 通过模块化的方式生成错误信息，可以使用`fmt.Errorf` 。

   这个方法相当于先调用`fmt.Sprintf`得到确切的错误信息，再调用`errors.New`函数，得到包含错误信息的error类型值。最后返回该值。

使用error的案例：

```go
package main

import (
	"errors"
	"fmt"
)

func echo(request string) (response string, err error) {
	if request == "" {
		err = errors.New("empty request")
		return
	}
	response = fmt.Sprintf("echo: %s", request)
	return
}

func main() {
	for _, request := range []string{"", "hello!"} {
		fmt.Printf("request: %s\n", request)
		resp, err := echo(request)
		if err != nil {
			fmt.Printf("error: %s\n", err)
			continue
		}
		fmt.Printf("response: %s \n", resp)
	}
}
```

## 二、怎么判断一个错误值具体代表那一类错误

1. 对于类型在已知范围内的一系列错误，一般使用类型断言表达式或类型switch语句来判断；
2. 对于已有相应变量且类型相同的一系列错误，一般直接使用判等操作来判断；
3. 对于没有相应变量且类型未知的一系列错误值，只能使用其错误信息的字符串表示形式来判断；

### （1）知道错误类型的所属范围

```go
import (
	"os"
	"os/exec"
)

func underlyingError(err error) error {
	switch errtype := err.(type) {
	case *os.PathError:
		return errtype.Err
	case *os.LinkError:
		return errtype.Err
	case *os.SyscallError:
		return errtype.Err
	case *exec.Error:
		return errtype.Err
	default:
		return err
	}
}
```

### （2）知道错误变量是哪几个值

```go
func knownError(err error) {
	switch err {
	case os.ErrClosed:
		fmt.Println("errClosed")
	case os.ErrInvalid:
		fmt.Println("errInvalid")
	case os.ErrPermission:
		fmt.Println("errPermission")
	}
}
```

## 三、错误值体系的两种方法

### 3.1 （立体的）错误类型体系

用类型建立起树形结构的错误体系，用统一字段建立起可追根溯源的链式错误关系。

- 将error作为嵌入接口。

- 使用名为Err、类型为error接口类型的字段，代表当前错误的潜在错误。错误类型的值之间的另外一种关系：链式关系。

### 3.2 （扁平的）错误值列表

通过`errors.New`函数生成错误值，预先创建一些代表已知错误的错误值。

隐患：通过`errors.New`函数生成的错误值只能被赋给变量，而不能赋给常量。又因为这些变量需要给包外代码使用，所以只能是公开的。这样带来的问题：恶意代码修改了变量的值，相应的判等操作的结果也会随之改变。

解决方案一：私有化变量，也就是说让首字母小写，然后编写公开的用于获取错误值以及用于判等错误值的函数。

解决方案二：此方案存在于syscall包中，使用其中一个叫Errno的类型，该类型代表了系统调用时可能发生的底层错误。这个错误类型是error接口的实现类型，同时也是对内建类型uintptr的再定义类型。由于uintptr可以作为常量类型，所以`syscall.Erron`也可以作为错误的常量类型。**可以仿照这种方式来构建我们自己的错误值列表。**



